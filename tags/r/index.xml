<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on zsc</title>
    <link>/tags/r/</link>
    <description>Recent content in R on zsc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 16 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/r/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>R动画</title>
      <link>/md/2020-08-16-r%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-08-16-r%E5%8A%A8%E7%94%BB/</guid>
      <description>R 动画 动画的本质是有n张图片进行拼接,到达欺骗人的眼睛.
在R中有常见的有两个包.
gifski 包, 搭配 rmd 文件使用, gganimation 包 gifski 包 安装 gifski 包：
xfun::pkg_load2(&amp;#39;gifski&amp;#39;) 再用代码段选项 animation.hook=&#39;gifski&#39;，如:
```{r, animation.hook=&amp;#39;gifski&amp;#39;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&amp;#39;red&amp;#39;, &amp;#39;yellow&amp;#39;), labels = NA) } ``` 则会直接生成gif动画
https://slides.yihui.org/2020-bearclub-rmarkdown.html#7
gganimation 包 见官网</description>
    </item>
    
    <item>
      <title>画函数图像--R语言</title>
      <link>/md/2020-08-15-%E7%94%BB%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8Fr%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-08-15-%E7%94%BB%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8Fr%E8%AF%AD%E8%A8%80/</guid>
      <description>据我了解, 计算机软件中画的函数图像大概有两种方法:
方法一: 该图像有一系列密集点组成, 已达到欺骗人们的眼睛.感觉认为是连续的. 方法二: 为了解决方法一种的问题,把每两个点之间用直线连接已达到连续的状态 在本文中我们将利用R语言来画函数图像&amp;mdash;- 重点以ggplot2来展示
1. $y = f(x)$ 的函数图像 比如:
$$ \begin{aligned} y &amp;amp;= sin(x),\ y &amp;amp;= cos(x), \ y &amp;amp;= \dfrac{1}{1+e^{(-x)}},\ y &amp;amp;= x^2 . \end{aligned} $$
这是我们中学最常见的函数.
方法一: curve()画函数图像 所用函数调用格式
curve(expr, from = NULL, to = NULL, n = 101, add = FALSE, type = &amp;#34;l&amp;#34;, xname = &amp;#34;x&amp;#34;, xlab = xname, ylab = NULL, log = NULL, xlim = NULL, ...) # expr：函数名称或一个关于变量x的函数表达式； # from，to：表示绘图的起止范围； # n：一个整数值，表示x取值的数量； # add：是一个逻辑值，当为TRUE时，表示将绘图添加到已存在的绘图中； # type：与plot函数中type含义相同 #定义公式 sigmoid &amp;lt;- function(x) 1/(1+exp(-x)) #画sigmid图像 curve(sigmoid,-10,10) #画sin(x)函数图像 curve(sin,-10,10) # 画y=x^2的图像 curve(x^2,-10,10) 方法二: ggplot2 首先介绍两个映射</description>
    </item>
    
    <item>
      <title>latex 缩写期刊</title>
      <link>/md/2020-08-11-latex%E7%BC%A9%E5%86%99%E6%9C%9F%E5%88%8A/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-08-11-latex%E7%BC%A9%E5%86%99%E6%9C%9F%E5%88%8A/</guid>
      <description>以下软件对参考文献都不能完美的满足我的要求, 因此可以结合不同软件的优势,达到最后的效果
1. zotero 设置—首选项—bitter bibtex —export — 最下面有一个期刊缩写,选购就能导出缩写的期刊名了
特点: 使用该软件, 系统自带的期刊缩写对照表很少, 且不能添加对照表, 不会自动更新bib文件 可以按照key键的顺序(升序) 导出bib数据库, 只需导出时选中[biter bibtex]选项即可 也可以安装以前的方式导出bib数据库, 只需导出时选中[bibtex]选项即可 2. Mendeley 特点: 默认情况下, 联网会自动更新bib数据库, 这一点很烦(for me), 因此可以直接断网使用该软件 期刊缩写很好,内置了很多比较全的期刊缩写.但某些期刊仍不全面,且缩写的格式看不见 3. Jabref软件 特点:
内置的期刊缩写相对较少, 但是可以手动添加期刊缩写列表(官网有), 就是电脑卡
由于bib文件中使用的是\&amp;amp; , 而jabref软件中默认使用&amp;amp;, 这样对照表中可能不会存在相应的缩写
不能导出按照key键顺序导出相应的bib文件
使用期刊缩写时,首先使用展开期刊全名,才去缩写,不然有可能找不到,
不会自动更新bib文件
下面是使用期刊缩写步骤, 先管理期刊缩写名(选择使用哪种类型的对照表),在进行期刊缩写
4. 自用软件包journalabbr 利用Jabref软件提供了大量的期刊缩写列表https://github.com/JabRef/abbrv.jabref.org,但是在Jabref软件中使用经常死机. 借助 pandoc , 该软件提供了大量命令参数, 感兴趣的可以去探索, 而xieyihui 通过使用*.Rmd文件进行了封装(前提要安装并了解R + Rstudio), 个人在巨人的肩上, 进行了简单封装,提供了一个R包journalabbr提供了一个本地app 和一个在线app, 解决了Jabref缩写期刊时遇到的缺点. 该app主要功能: 提供期刊缩写, 美化bib数据库文件以及提供类似bst文件那样批量生成一个完整的 thebibliography 环境. app截图如下: </description>
    </item>
    
    <item>
      <title>R&amp;shiny自动截图</title>
      <link>/md/2020-05-18-shiny%E6%88%AA%E5%9B%BE/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-05-18-shiny%E6%88%AA%E5%9B%BE/</guid>
      <description>利用webshot 进行截图 library(shiny) library(ggplot2) histogram &amp;lt;- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) { df &amp;lt;- data.frame( x = c(x1, x2), g = c(rep(&amp;#34;x1&amp;#34;, length(x1)), rep(&amp;#34;x2&amp;#34;, length(x2))) ) ggplot(df, aes(x, fill = g)) + geom_histogram(binwidth = binwidth) + coord_cartesian(xlim = xlim) } ui &amp;lt;- fluidPage( fluidRow( column(3, numericInput(&amp;#34;lambda1&amp;#34;, label = &amp;#34;lambda1&amp;#34;, value = 3), numericInput(&amp;#34;lambda2&amp;#34;, label = &amp;#34;lambda2&amp;#34;, value = 4), numericInput(&amp;#34;n&amp;#34;, label = &amp;#34;n&amp;#34;, value = 1e4, min = 0), # 增加一个按钮 actionButton(&amp;#34;simulate&amp;#34;, &amp;#34;Simulate!</description>
    </item>
    
    <item>
      <title>创建属于自己的rmarkdown模板文件</title>
      <link>/md/2020-05-18-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84rmd%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-05-18-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84rmd%E6%A8%A1%E6%9D%BF/</guid>
      <description>rmarkdown模板文件的创建 &amp;mdash;- 修改prettydoc模板
下载链接: zscbeautiful
下载下来后, 把css和html 分别放在对应的目录中替换即可
Tip: 我的mac路径为/Library/Frameworks/R.framework/Versions/4.0/Resources/library/prettydoc/ , 只需把下载下来的文件进行替换即可
创建模板的步骤: 新建文件 &amp;mdash;&amp;gt; R mardown &amp;mdash;&amp;gt; From Template
如图:
参考: https://cosx.org/2019/10/prettydoc-internals-ljj/</description>
    </item>
    
    <item>
      <title>基本绘图中添加指定中文字体</title>
      <link>/md/2020-03-10-r%E8%AF%AD%E8%A8%80%E7%BB%98%E5%9B%BE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-03-10-r%E8%AF%AD%E8%A8%80%E7%BB%98%E5%9B%BE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</guid>
      <description>基本绘图中添加指定中文字体 方法一: 使用par(family=&#39;STKaiti&#39;) , 方法二: 直接在画图函数后添加family 参数指定字体,在R.3.6.x 已经不可以了 barplot(df[sex == &amp;#39;男&amp;#39;,table(Year)],main = &amp;#34;男性条形统计图&amp;#34;,family = &amp;#39;Songti SC&amp;#39;) 方法三: 使用showtext包,需要xquartz软件,可以使用brew cask install xquartz library(showtext) #使用下面的函数查看所有字体,选择中文字体添加 font_files() showtext_auto(enable = TRUE) font_add(&amp;#39;Songti&amp;#39;, &amp;#39;Songti.ttc&amp;#39;,&amp;#39;STKaiti&amp;#39;,&amp;#39;STXihei&amp;#39;) #添加中文字体 quartz(family = &amp;#34;STXihei&amp;#34;) #可以把STXihei替换成任意想要的字体，如&amp;#39;Songti&amp;#39;, &amp;#39;Songti.ttc&amp;#39;,&amp;#39;STKaiti&amp;#39;等 方法四: extrafontdb 软件包 方法五: ggplot2绘图中添加指定中文字体 library(ggplot2) p = ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) + geom_point() p = p + labs(title = &amp;#34;iris数据集&amp;#34;) p = p + theme(plot.title = element_text(hjust = 0.</description>
    </item>
    
    <item>
      <title>R中常用的批处理操作</title>
      <link>/md/2019-11-19-r%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-11-19-r%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</guid>
      <description>批量重命名文件名 setwd(&amp;#39;/Users/zsc/Desktop/音乐mp3/&amp;#39;) library(stringr) oldname = list.files(pattern = &amp;#39;.*mp3&amp;#39;) newname = str_extract(d,&amp;#39;.*(?=158)&amp;#39;) df = data.frame(oldname = oldname, newname = newname) df file.rename(df$oldname, df$newname) 批量统计 pdf 的页数 library(qpdf) setwd(&amp;#39;/Users/zsc/Desktop/pdf/&amp;#39;) d = list.files() d d1 = str_extract(d,&amp;#39;.*?.pdf$&amp;#39;) library(purrr) map_dbl(d1, pdf_length) map_dbl(d1, pdf_length) %&amp;gt;% sum() 移除latex生成的临时文件 p = getwd() cat(p,&amp;#39;\n&amp;#39;) t = &amp;#39;*.aux|*.bbl|*.bcf|*.blg|*.log|*.xml|*.out|*.spl|*.synctex.gz&amp;#39; del = list.files(path = p,pattern = t) file.remove(del) </description>
    </item>
    
    <item>
      <title>MATLAB 与 R 在排序上的区别</title>
      <link>/matlab/2019-11-15-matlab-r-rank/</link>
      <pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/matlab/2019-11-15-matlab-r-rank/</guid>
      <description>MATLAB 与 R 在排序上的区别 R 中的 rank , 返回一个向量的秩 R语言排序有几个基本函数： sort()；rank()；order() sort（）是对向量进行从小到大的排序 rank（）返回的是对向量中每个数值对应的秩 order（）返回的值表示位置，依次对应的是向量的最小值、次小值、第三小值......最大值 &amp;gt; data=c(5,6,8,2,4,9) &amp;gt; sort(data) [1] 2 4 5 6 8 9 &amp;gt; rank(data) % 秩,即排序后的位置,比如 data 中的第一个元素 5,在升序排序中是占第 3 个位置,所以返回 3. [1] 3 4 5 1 2 6 &amp;gt; order(data) [1] 4 5 1 2 3 6 MATLAB [y , index] = sort(x); y 把 x 排列升序后的结果 % 类似 R 中的 sort index 为 x 的秩 % 类似 R 中的 order tiedrank(data) % 类似 R 中的 rank, 返回平均秩, ans = 3 4 5 1 2 6 &amp;gt;&amp;gt; data=[5,6,8,2,4,9]; [y, index] =sort(data) y = 2 4 5 6 8 9 index = 4 5 1 2 3 6 有 y == data(index) &amp;gt;&amp;gt; tiedrank(data) ans = 3 4 5 1 2 6 tiedrank([10 20 30 40 20]) % 返回平均秩 ans = 1 2.</description>
    </item>
    
    <item>
      <title>非线性规划2</title>
      <link>/md/2019-06-24-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</link>
      <pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-06-24-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</guid>
      <description>Rsolnp 非线性规划问题
$$ \begin{aligned} \min \quad &amp;amp; f(x)\ \text { s.t. } &amp;amp; \begin{cases} {g(x)=0} \{l_{h} \leq h(x) \leq u_{h}} \ {l_{x} \leq x \leq u_{x}} \end{cases} \end{aligned} $$
其中, $f(x),g(x),h(x)$ 都是光滑函数,
solnp(pars, fun, eqfun = NULL, eqB = NULL, ineqfun = NULL, ineqLB = NULL, ineqUB = NULL, LB = NULL, UB = NULL, control = list(), ...) # 参数解释 pars : 初始值(向量), fun : 最小化的目标函数值，输入为pars参数，输出为一个单一值,等价上述问题的f(x) eqfun : (可选) 等式约束(左边) ，等价与上述问题的 g(x) egB : (可选) 等式约束右边值，等价上述问题g(x) = 0 的0 ineqfun : (可选) 不等式约束，等价上述问题的 h(x) ineqLB :(可选) 不等式约束的下限 ，等价于上述问题的 lh ineqUB :(可选) 不等式约束的上限 ，等价于上述问题的 uh LB :(可选) 参变量的下限 ，等价于上述问题的lx UB: (可选) 参变量的上限 ，等价于上述问题的ux control :(可选) 优化参数控制表。 例子： $$ \begin{aligned} \min &amp;amp; \quad exp({\prod_{i=1}^{5}x_i}) \ \text {s.</description>
    </item>
    
    <item>
      <title>动态可视化如此简单</title>
      <link>/md/2019-05-26-dongtaikeshihua/</link>
      <pubDate>Sun, 26 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-05-26-dongtaikeshihua/</guid>
      <description>动态可视化如此简单 不用任何代码，只需要知道你画什么图，需要什么数据格式，就可以画出漂亮的动态图了，并且有每种可视化都有相应数据案例，很方面。
由于是国外的网站，可能有点慢。
网站： https://app.flourish.studio/templates
可以参考这篇微信文章： https://mp.weixin.qq.com/s/aQfpyVtmjDp8kmzce3k11w
这个非常方便的可以嵌入到网页上去，
直接复制粘贴到markdown即可
如果要进行数据分析可视化 也可以使用IBM Watson Analystics，这个画热力地图非常方面</description>
    </item>
    
    <item>
      <title>R结合C&#43;&#43;</title>
      <link>/md/2019-05-24-randc/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-05-24-randc/</guid>
      <description>1. R结合C++ 首先要配置好R和C++的环境，在R官网中分别有不同操作系统的环境配置条件，按照下载R软件的步骤，在下载R软件页面有相应的配置说明。如果是mac系统也可以参考这篇文章：macOS
基本的用法可以参考：
http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/rcpp.html
个人建议要写c++ 代码给R软件使用，建议不要混合编程，我只是简单的实验过，这样会降低代码运行的效率，甚至，可能比R本身的运算还慢。
基本的c++ 大概能写一些简单的循环运算，但要涉及比较复杂的矩阵运算此时需要额外的库，不过不怕麻烦你自己也可以用c++写，这里推荐使用Armadillo 库，语法和MATLAB很相似，上手很快。
由于查资料发现，Armadillo 被RcppArmadillo包给封装了，但基本没有对其做任何更改，所以你只需要简单的引入相应的Rcpp环境，就能简单的写c++了，再次说明，c++中最好不要混写R代码。
CSDN上有关Armadillo库的介绍，个人觉得还不错，https://blog.csdn.net/jnulzl/article/details/46808515
c++ 并行运算对比 以及RcppArmadillo包的使用，如下，先做总结，推荐使用feature.apply包来并行c++代码，虽然有时候没有C++ openMP快，但是基本上符合人们需求，而且feature.apply包使用起来很简单，相对于其他R并行计算的包，不出错，记得使用doParallel包来并行C++总是出错，所以推荐feature.apply并行。
2. R运行速度对比 2.1 C++ 加上 feature.apply 并行 把下面的代码存为sample_c.cpp，然后运行Rcpp::sourceCpp(&#39;sample_c.cpp&#39;)即可
sample_mat ： 随机构造n阶正互反判断矩阵 eig_max： 求矩阵的最大特征值 veig_max(int n,int k =10000): 求k个n阶的最大特征值，返回一个向量。 // [[Rcpp::depends(RcppArmadillo)]] #include &amp;lt;RcppArmadillo.h&amp;gt; #include &amp;lt;Rcpp.h&amp;gt; using namespace Rcpp; using namespace arma; // [[Rcpp::export]] mat sample_mat(int n) { // 第一步： 随机构造n阶正互反判断矩阵 vec P = {1,2,3,4,5,6,7,8,9,1/2.0,1/3.0,1/4.0,1/5.0,1/6.0,1/7.0,1/8.0,1/9.0}; vec v = randu&amp;lt;vec&amp;gt;(0.5*n*(n-1)); //声明一个向量，并赋予随机值 v *= 17; v = floor(v); mat A(n,n); // 声明一个n*n的矩阵 int i = 0,j = 0,k=0,temp = 0; for(i = 0; i&amp;lt;n;i++){ for(j =0; j&amp;lt;n;j++){ if( i &amp;gt;j){ temp = static_cast&amp;lt;int&amp;gt;(v(k++)); A(i,j) = P(temp); A(j,i) = 1/ P(temp); }else{ A(i,j) =1; } } } return(A); } // [[Rcpp::export]] double eig_max(mat A) { // 第二步：求矩阵的最大特征值 cx_vec eigval = eig_gen(A); return max(real(eigval)); } // [[Rcpp::export]] NumericVector veig_max(int n,int k =10000){ int m = 0; mat A; NumericVector res(k); for(m = 0; m&amp;lt;k;m++){ A = sample_mat(n); res(m) = eig_max(A); } return res; } 2.</description>
    </item>
    
    <item>
      <title>环境</title>
      <link>/md/2019-05-02-environment/</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-05-02-environment/</guid>
      <description>环境 详细的解释可以查看书《高级R语言编程指南》,这里总结一份与环境有关的函数总结：(参考R语言核心技术手册第二版)
函数 描述 assign 在envir环境中将名称x赋给value对象 get 在envir环境中获得与名称x关联的对象 exists 判断在环境envir是是否定义了名称x objects 以向量的形式返回envir环境中定义的所有(对象)名称 remove 从envir环境中将参数中罗列的对象删除(列表不适合作为参数的名称，尤其当参数是向量时) search 以向量的形式列出全局环境的所有父环境，也称为搜索路径 searchpaths 以向量的形式返回全局环境的所有父环境的路径 attach 将列表、数据框或数据文件中的对象添加到当前的搜索路径中 detach 将列表、数据框或数据文件中的对象从当前的搜索路径中删除 emptyenv 空环境对象，它是所有环境的祖先，也是唯一一个没有父环境的的环境 parent.env 查看envir环境的父环境 baseenv 基础环境，它是R基础软件包的环境，它的父环境是空环境 globalenv(或.GlobalEnv) 用户的工作环境，也叫全局环境，通常情况下我们就是在这个环境中工作的，全局环境的父环境是由library() 或require()添加的最后一个添加包 environment 它是当前环境，(默认情况下，当前环境等于全局环境) new.env 手动创建一个新的环境对象 parent.frame 返回函数被调用的环境 ,即可以访问调用环境的父环境，常常作为参数使用，需要搭配其他函数eg:eval 函数调用 — 以堆栈的形式调用 调用栈的操作
函数 描述 sys.call 返回一个包含当前函数调用(包括参数)的语言对象 sys.frame 返回调用环境 sys.nframe 返回当前帧的编号(即在调用堆栈中的位置)，如果在R控制台中调用该函数，返回值为0, sys.function 返回当前计算的函数 sys.parent 返回父环境的编号 sys.calls 返回栈中所有帧的调用 sys.frames 返回栈中所有的环境 sys.parents 返回栈中每个帧的父帧 sys.on.exit 返回当前on.exit所使用的表达式 sys.status 返回一个列表 parent.frame 返回sys.frame(sys.parent(n)) ,即返回函数被调用的父环境，即允许访问调用父环境.常常作为参数使用，需要搭配其他函数eg:eval 参考 《R语言核心编程技巧第二版》</description>
    </item>
    
    <item>
      <title>数据框删除列的方法汇总</title>
      <link>/md/2019-05-01-remove-dataframe-columns/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-05-01-remove-dataframe-columns/</guid>
      <description>数据框删除列 iris[1:10,-5] # 1. 通过索引删除列 iris[1:10,-c(4,5)] # 删除多列 iris[1:10,-which(names(iris)%in%c(&amp;#34;Petal.Width&amp;#34;,&amp;#34;Species&amp;#34;))]# 2.根据列名进行删除 subset(iris, select = -c(Petal.Width, Species))# 3 根据列名进行删除 iris[1:10,1:4]# 筛选出需要的列 </description>
    </item>
    
    <item>
      <title>学术论文写作工具</title>
      <link>/md/2019-04-26-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-04-26-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/</guid>
      <description>1. 基础配置 1、必备： CTEX套装 或者 TexLive (推荐),安装Texlive时候，推荐搭配Texstudio
2、有没有发现写公式很麻烦：mathpix 工具可以直接截图，把截图的公式转变为Latex 代码，太复杂的可能识别不了，但是已经很好了
3、AxMath 可以像mathtpye那样输入公式，更重要的一点是可以直接转变为latex代码，
4、LaTeX代码转为Word公式:
​	可以参考这篇文章： http://www.latexstudio.net/archives/4650.html
​	如果在word里面直接输入LaTex代码转word公式,eg: 输入$x^2 + y^2$ ,然后选中其按 alt + \ 即可转换，不过有点慢，耐心等待
5、 Typora 工具，写markdown的，可以写md文件，然后转出latex文件，不过转出的导言区一般是有问题的，我们直接要正文部分，向导言区的头文件之类，要根据文件适当自己添加，这是由于公式的问题，公式之间不能用空行。
\documentclass{article} \usepackage{ctex} % 中文包,如果含有公式也适用 \usepackage[colorlinks,linkcolor=red]{hyperref} % 超链接 \begin{document} 。。。正文。。。。。x \end{document} 6、推荐写公式时，不用空白行。
2. 表格to latex 方法一：http://www.tablesgenerator.com/latex_tables :这个网站不错，就是打开有点慢（推荐）。 以及这个网站https://tableconvert.com/ 方法二： 可以安装Excel2latex 插件，自己百度 方法三：在rstudio中使用stargazer包 (三线头表格,头是双线） 方法四： 在rstudio中使用xtable包( 三线头表格，头是单线) ##### 方法三：##### library(stargazer) library(xlsx) # 推荐使用这个包，因为不会发生小数点精度的问题，但是列名可能会发生改变 # 原本的列名是 3，4，....,9 读入后变成了X3,X4,....,X9. data = read.xlsx(file =&amp;#34;工作簿1.xlsx&amp;#34;,sheetIndex = 1, header = T,colClasses = &amp;#34;character&amp;#34;) data stargazer(data,summary = F,rownames = F) ##### 方法四： ##### xtable::xtable(head(iris),digits=3,caption=&amp;#34;Head of Iris Data&amp;#34;) # 其中函数中的digits=3控制输出精度，caption就是表格的标题。 注意看下图： 把代码粘贴到latex编译器中，上图为方法三画的(一般学术论文，表的标题在上方，图的标题在下方) ，下图为方法四画的。</description>
    </item>
    
    <item>
      <title>不确定多属性决策方法徐泽水pdf</title>
      <link>/uncertain/2019-02-25%E4%B8%8D%E7%A1%AE%E5%AE%9A%E5%A4%9A%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E5%BE%90%E6%B3%BD%E6%B0%B4pdf/</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-25%E4%B8%8D%E7%A1%AE%E5%AE%9A%E5%A4%9A%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E5%BE%90%E6%B3%BD%E6%B0%B4pdf/</guid>
      <description>https://cdn.jsdelivr.net/gh/zscmmm/imgs2208save@master/img/xuzeshui不确定多属性决策方法及应用_徐泽水.pdf</description>
    </item>
    
    <item>
      <title>运筹学与最优化--在R软件中的实现</title>
      <link>/md/2019-02-18-%E8%BF%90%E7%AD%B9%E5%AD%A6%E4%B8%8E%E6%9C%80%E4%BC%98%E5%8C%96r/</link>
      <pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-02-18-%E8%BF%90%E7%AD%B9%E5%AD%A6%E4%B8%8E%E6%9C%80%E4%BC%98%E5%8C%96r/</guid>
      <description>转载过来的，
参考链接1:
参考链接2:
备注链接:</description>
    </item>
    
    <item>
      <title>运筹学最短路问题</title>
      <link>/md/2018-11-22-%E8%BF%90%E7%AD%B9%E5%AD%A6%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 22 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-22-%E8%BF%90%E7%AD%B9%E5%AD%A6%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</guid>
      <description>最短路算法参考(自制ppt)pdf:</description>
    </item>
    
    <item>
      <title>用c语言设置定时关机</title>
      <link>/md/2018-11-20-c%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-20-c%E8%AF%AD%E8%A8%80/</guid>
      <description>C代码 创建定时任务 发现代码，win有自动防范木马的可能，于是要手动去在定时任务勾选某些指标，所以不可行。
# include&amp;lt;stdio.h&amp;gt; # include &amp;lt;windows.h&amp;gt; int main() { //如果存在任务名为myTaskName2 则强制删除，若没有则报错，但不终止该程序的运行 system(&amp;#34;schtasks /delete /tn myTaskName2 /f&amp;#34;); // 创建一个任务名为myTaskName2的任务,/tr 后面是 要执行的命令， 双引号要转义，/st 后面接的是触发时间 system(&amp;#34;schtasks /create /tn myTaskName2 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 22:35:00&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName4 /f&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName4 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 22:42:00&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName3 /f&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName3 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 22:52:00&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName5 /f&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName6 /f&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName7 /f&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName5 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:00:00&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName6 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:15:00&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName7 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:27:00&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName8 /f&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName9 /f&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName8 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:43:00&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName9 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:58:00&amp;#34;); return 0; } 编译运行后 编译运行后，找到对应得exe文件 ,把其放在开始启动目录中即可（C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp）</description>
    </item>
    
    <item>
      <title>运筹学与最优化matlab</title>
      <link>/md/2018-11-19-%E8%BF%90%E7%AD%B9%E5%AD%A6%E4%B8%8E%E6%9C%80%E4%BC%98%E5%8C%96matlab/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-19-%E8%BF%90%E7%AD%B9%E5%AD%A6%E4%B8%8E%E6%9C%80%E4%BC%98%E5%8C%96matlab/</guid>
      <description>运筹学与matlab</description>
    </item>
    
    <item>
      <title>线性规划的一般模型(草稿)</title>
      <link>/md/2018-11-17-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E8%88%AC%E6%A8%A1%E5%9E%8Btest/</link>
      <pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-17-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E8%88%AC%E6%A8%A1%E5%9E%8Btest/</guid>
      <description>线性规划的一般模型 :
$$ \begin{aligned} \min \quad z &amp;amp;= c_1x_1+c_2x_2+ \cdots + c_nx_n \ s.t. \quad &amp;amp; \begin{cases} &amp;amp; a_{11}x_1+a_{12}x_2+ \cdots + a_{1n}x_n \leq b_1 \ &amp;amp; a_{21}x_1+a_{22}x_2+ \cdots + a_{2n}x_n \leq b_2 \ &amp;amp; \quad \cdots \qquad \cdots \qquad \cdots \ &amp;amp; a_{m1}x_1+a_{m2}x_2+ \cdots + a_{mn}x_n \leq b_m \ &amp;amp; x_1,x_2,x_3,\cdots,x_n \geq 0 \end{cases} \end{aligned} $$</description>
    </item>
    
    <item>
      <title>重装系统后一些有用的激活工具</title>
      <link>/md/2018-11-17-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-17-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</guid>
      <description>包含win10 和office2019 激活工具 链接：https://pan.baidu.com/s/1eOQUPdlrvViL2XSucEdkmQ 提取码：08be 复制这段内容后打开百度网盘手机App，操作更方便哦</description>
    </item>
    
    <item>
      <title>R语言发邮件--mailR包</title>
      <link>/md/2018-11-13-%E5%8F%91%E9%82%AE%E4%BB%B6mailr%E5%8C%85/</link>
      <pubDate>Tue, 13 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-13-%E5%8F%91%E9%82%AE%E4%BB%B6mailr%E5%8C%85/</guid>
      <description>亲测试邮箱为163邮箱 和QQ邮箱
mailR 包参数 mailR 包中只有一个接口函数&amp;mdash;send.mail ,该包依恋java环境，请首先配置该环境，下面是该函数的一些基本参数：
send.mail(from, to, subject = &amp;#34;&amp;#34;, body = &amp;#34;&amp;#34;, encoding = &amp;#34;iso-8859-1&amp;#34;, html = FALSE, inline = FALSE, smtp = list(), authenticate = FALSE, send = TRUE, attach.files = NULL, debug = FALSE, ...) 参数 说明 from 发件人邮箱 to 收件人邮箱 subject 邮件标题 body 邮件的内容(正文),内容可以是文本也可以是html网页格式 html 一个bool值，是否应该讲邮箱正文解析为HTML inline 一个bool值，HTML文件中的图像是否应该被嵌入 smtp 重要的参数，设置服务器参数用的 authenticate 是否应该使用smtp中的参数 attach.files 指定相应的附件，若是多个则用字符向量表示 file.names （省略参数），对相应的附件进行重命名 debug 你是否要查看详细的调试信息 163 邮箱: 如果发送频率过快，容易被封号，暂时发布出去了，只有等解封以后再发,
注意： 在测试的时候，尽量写的和平时邮件一样的格式，不然会被认为是垃圾邮件
library(mailR) sender &amp;lt;- &amp;#34;********@163.</description>
    </item>
    
    <item>
      <title>谈谈字符编码问题</title>
      <link>/md/2018-11-06-%E8%B0%88%E8%B0%88%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 06 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-06-%E8%B0%88%E8%B0%88%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</guid>
      <description>最近在实验室编写文件，遇到一件奇怪的事情，在自己的笔记本上能正常编码，却在学校的电脑上编码总是乱码，于是经历种种磨难，算是弄明白了一点点，下面简单介绍一下字符编码的知识（由于编码种类繁多，我只简单的提一下，其余自己百度，文末有相关链接）
常见的字符集： ​	百度百科定义： 字符(Character)是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。字符集(Character set)是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。中文文字数目大，而且还分为简体中文和繁体中文两种不同书写规则的文字，而计算机最初是按英语单字节字符设计的，因此，对中文字符进行编码，是中文信息交流的技术基础。
​	下面介绍几个常见的字符集：ASCII字符集、GB2312、 GBK、utf-8、utf-16、utf-32
​	所谓字符集就是按一定的规则去解释或者翻译0 1 代码的，有点像翻译表或者对照表。
ASCII 以及EASCII ​	首先，我们要明白计算机内部所有东西都是以1和0来表示的，刚开始我们用8位0 1代码进行表示，一共有2^8= 256种状态，由于当时计算机很昂贵并且很大，美国人只有用了127个字符就表示了英语中所有的字符，这就是ASSIC码，从此ASSIC码诞生了，
并用后面的128~256号状态来表示西欧其他国家的字符，于是把0~256号状态的所有字符统称为扩展的ASCCI字符（即EASCII），即最高位为0 代表0~127号字符，最高位为1 是后面扩展的字符集,记住，此时计算机始终按照8位二进制进行编码.
GB2312 、GBK 、GB 18030 ​	等到了中国，发现这些0~256号状态都被别人使用了，而且中国的汉字太多，于是中国人准备用两个字节来表示一个汉字，并应该兼容最初的0~127号字符集，于是中国人这样设计，当最高位为0时，计算机就按ASSCI码(1位)进行编码，当发现最高位是1时，就按两个字节进行编码，eg: 1001000&#39;10001011 这两个字节都对应两个十进制数分别是72和11 ，于是就想设计一个二维矩阵建立与汉字的对应关系，按照这个二维矩阵的行和列一样进行查找对比，就可以确定一个汉字了，并且保留了0~127号码的对应规则（这就是我们经常发现为什么英文不乱码而中文乱码的原因）.
​	这个二维矩阵对应的字符集，就成为GB2312字符集,这样和后面的EASCCI就冲突了，然而日本、韩国等世界上几乎每个国家都有自己的字符集，于是后面的第128~256号字符集经常发生冲突（即乱码，计算机不知道应该按照GB2312、EASSIC、日文的字符集、等进行编码，所有就会出现乱码 ）。
​	这里补充说明一点，GB2312字符集表示的汉字也比较少，于是在GB2312的基础上扩展产生GBK编码以及GB 18030 等汉字字符集)
ANSI ​	严格说ANSI并不是一个字符集。前面我们讲到每个国家都有自己的编码规则，于是Windows公司设计了ANSI规则，ANSI根据电脑操作系统的设置，自动关联对应的编码，eg： 在美国就按ASCII码进行编码，并自动设置为默认编码,同理在中国，就按GBK进行编码，而在日本，就按日本对应的字符集进行编码&amp;hellip;&amp;hellip;
​	所以ANSI简单来说是一个自动判别系统,但这样在不同字符进行切换时，就会出现乱码的问题。于是迫切希望有同一的编码规则，于是Unicode 编码孕育而生。
Unicode 、utf-8、utf-16、utf-32 ​	由于世界上存在多种编码，当不同国家的人在进行发送文件时，会出现乱码（因为解读的规则不一样，同一段0 1 代码，中国按照GBK去解读，而西欧安装EASSCI字符集去解读，这样必然计算机弄不清楚，必会出现乱码）,于是有一个社区就说要不我们把世界上的所有文字都进行统一编码吧！这样就不会产生乱码了，于是产生了Unicode编码，当然Unicode是一个很大的集合，大概用了4个字节（即32位 0 1代码去表示）,这样美国人或者西欧人不干了，因为原本我存储一个英文单词words只需要5个字节，现在用Unicode就变成了20个字节，这样硬盘的空间严重浪费，于是产生出来utf-8、utf-16、utf-32字符集，这里重点解释一下utf-8字符集，这个是可变长编码，计算机可以根据前面的一个1个字节的编码规则进行自动判断，该是用一个字节去解读还是用2个、3个字节去解读(这里这个规则有点复杂，反正计算机能从第一个字节中解读出来，到底应该用几个字节取解读)。
utf-8 : 使用1~4个字节存储一个Unicode字符。 utf-16 : 使用2或4个字节存储 utf-32 : 使用4个字节存储 乱码产生的原因 ​	假设在一个文本编辑器中写入hollo world 你好世界 ，编码方式为utf-8，
​	当按下ctrl + s时，文本编辑器将会按照unicode字符集中查找每个字符对应的码，再按照utf-8的方式，将hollo world存为单字节，而将你好世界存成2~4个字节，此过程称为 编码。</description>
    </item>
    
    <item>
      <title>猫眼电影票房抓取</title>
      <link>/md/2018-07-15-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8A%93%E5%8F%96/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-07-15-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8A%93%E5%8F%96/</guid>
      <description>猫眼电影票房抓取 基本设置 library(RSelenium) library(stringr) setwd(&amp;#34;C:\\RSelenium&amp;#34;) ######## 初始化浏览器#### remDr &amp;lt;- remoteDriver( browserName = &amp;#34;chrome&amp;#34;, # 浏览器可以自己设置firefox、chrome、phantomjs（要配置） remoteServerAddr = &amp;#34;localhost&amp;#34;, port = 4444L) remDr$open() # 打开浏览器 #&amp;gt; [1] &amp;#34;Connecting to remote server&amp;#34; #&amp;gt; $applicationCacheEnabled #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $rotatable #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $mobileEmulationEnabled #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $networkConnectionEnabled #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $chrome #&amp;gt; $chrome$chromedriverVersion #&amp;gt; [1] &amp;#34;2.37.544315 (730aa6a5fdba159ac9f4c1e8cbc59bf1b5ce12b7)&amp;#34; #&amp;gt; #&amp;gt; $chrome$userDataDir #&amp;gt; [1] &amp;#34;C:\\Users\\zsc\\AppData\\Local\\Temp\\scoped_dir10136_5944&amp;#34; #&amp;gt; #&amp;gt; #&amp;gt; $takesHeapSnapshot #&amp;gt; [1] TRUE #&amp;gt; #&amp;gt; $pageLoadStrategy #&amp;gt; [1] &amp;#34;normal&amp;#34; #&amp;gt; #&amp;gt; $databaseEnabled #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $handlesAlerts #&amp;gt; [1] TRUE #&amp;gt; #&amp;gt; $hasTouchScreen #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $version #&amp;gt; [1] &amp;#34;67.</description>
    </item>
    
    <item>
      <title>相关图之corrgram</title>
      <link>/md/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bcorrgram/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bcorrgram/</guid>
      <description>相关图： 所谓相关图是基于变量间的相关系数大小，通过可视化方法反应不同变量组合间相关关系的差异图形。可以把相关图分为相关矩阵图、相关层次图
相关矩阵图 R语言中，绘制相关矩阵图的包主要有两个：corrgram::corrgram和corrplot::corrplot
此处都以mtcars数据集为例，说明这两个函数的使用
相关矩阵图 &amp;mdash; &amp;mdash; corrgram corrgram::corrgram()函数 corrgram(x, type = NULL, order = FALSE, labels, panel = panel.shade, lower.panel = panel, upper.panel = panel, diag.panel = NULL, text.panel = textPanel, label.pos = c(0.5, 0.5), label.srt = 0, cex.labels = NULL, font.labels = 1, row1attop = TRUE, dir = &amp;#34;&amp;#34;, gap = 0, abs = FALSE, col.regions = colorRampPalette(c(&amp;#34;red&amp;#34;, &amp;#34;salmon&amp;#34;, &amp;#34;white&amp;#34;, &amp;#34;royalblue&amp;#34;, &amp;#34;navy&amp;#34;)), cor.method = &amp;#34;pearson&amp;#34;, outer.labels = NULL, .</description>
    </item>
    
    <item>
      <title>泰坦尼克号预测(kaggle)</title>
      <link>/md/2018-07-14-kaggle-%E6%B3%B0%E5%9D%A6/</link>
      <pubDate>Sat, 14 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-07-14-kaggle-%E6%B3%B0%E5%9D%A6/</guid>
      <description>options(width = 300) knitr::opts_chunk$set(message = F,warning = F,comment = &amp;#34;#&amp;gt;&amp;#34;,collapse = TRUE) 读入数据
library(data.table) train=fread(&amp;#34;data/train.csv&amp;#34;,na.strings = c(&amp;#34;&amp;#34;,NA)) test=fread(&amp;#34;data/test.csv&amp;#34;,na.strings = c(&amp;#34;&amp;#34;,NA)) #把两个合并起来进行数据处理--两个data.table的合并 combine =rbindlist(list(train,test),fill=TRUE) #### 其实个人不建议这样操作，因为不能把测试集和训练集一起处理，应该分开处理 数据处理
# 统计每一列的缺失率 combine[,lapply(.SD, function(x)sum(is.na(x)))] #&amp;gt; PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked #&amp;gt; 1: 0 418 0 0 0 263 0 0 0 1 1014 2 # 可以看出 我们需要对缺失列进行处理，以及一些特征衍生工作 library(zoo) library(purrr) combine[,Age := na.spline(Age)] # age变量进行处理，进行样条插补 combine[,Fare := na.spline(Fare)] # Fare变量进行处理，进行样条插补 由于Cabin 变量丢失数据太多，于是可以删除这个变量</description>
    </item>
    
    <item>
      <title>seq*函数族</title>
      <link>/md/2018-07-08-seq%E5%87%BD%E6%95%B0%E6%97%8F/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-07-08-seq%E5%87%BD%E6%95%B0%E6%97%8F/</guid>
      <description>seq(from = 1, to = 1, by = 步长（默认为1),length.out = NULL, along.with = NULL, ...) seq.int(from, to, by, length.out, along.with, ...) seq_along(along.with) seq_len(length.out) from：生成向量的起点， to：生成向量的终点，默认步长为1（可修改） length.out：向量中元素数目 along.with：表示生成的向量为现有一向量元素的索引 主要介绍seq_along(along.with) 和seq_len(length.out)函数，应用于循环中
比如:
# 要循环某个向量长度的次数,比如向量a，其长度未知 for(i in seq_along(a)){...} 代替 for(i in 1:length(a)){...} ## 经常犯这样的错误，不美观 # 循环中，循环1:10可以用一下方法 for(i in seq_len(10)){...} 代替 for(i in 1:10){...} head(x,5) : 取向量的前5个元素，向量 ，数据框 ，list都适用
tail(x,5): 取向量的后5个元素，等价 x[-(1:(length(x)-5))] 等价 x[(length(n-4):length(n)] </description>
    </item>
    
    <item>
      <title>正则表达式(通用)</title>
      <link>/md/2018-05-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9A%E7%94%A8/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-05-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9A%E7%94%A8/</guid>
      <description>正则表达式&amp;ndash;表格 注意： 由于每个软件的正则表达式的转义字符是不一样的，比如R中一般用\\.来代表匹配小数点. 表格中的\ ，但在软件中可能需要\\才能表达出来，eg:\d 匹配任意一个数字， 可能需要使用\\d 1. 基本的元字符 元字符 说明 . 匹配任意单个字符，字母、数字甚至是.字符本身 | 逻辑或操作符 [ ] 匹配该字符集合中的一个字符
（各个字符之间是or关系）
**注意: ** [.] 只匹配点本身,不是特殊字符,不用转义. [^ ] 对字符集合求非
就是排除该字符集合
[^0-9] ： 匹配任何不适数字的字符 - 定义一个区间,
[A-Za-z09]: 匹配(大小)字母和数字
-只有出现在[]之间才是元字符
-出现在其他地方，则表示一个普通字符 \ 对下一个字符进行转义 2. 数量元字符 元字符 说明 * 匹配前一个字符(或字符集合或子表达式)的零次或多次重复 + 匹配前一个字符(或字符集合或子表达式)的一次或多次重复 ? 匹配前一个字符(或字符集合或子表达式)的零次或一次重复 *? * 的懒惰型版本 +? +的懒惰型版本 {n} 匹配前一个字符(或字符集合或子表达式)的n次重复 {m,n} 匹配前一个字符(或字符集合或子表达式)至少m次且至多n次重复 {n, } 匹配前一个字符(或字符集合或子表达式)n次重复或更多次重复（至少n次） {n, }? {n, }的懒惰型版本 3. 位置元字符 元字符 说明 ^ 匹配字符串的开头 $ 匹配字符串的结束 \A 匹配字符串的开头（大多数语言不支持, 类似^） \Z 匹配字符串的结束（大多数语言不支持, 类似$） \&amp;lt; 匹配单词的开头（是\b的更细粒度控制，支持的语言并不多见） \&amp;gt; 匹配单词的结束（是\b的更细粒度控制，支持的语言并不多见） \b 匹配单词的边界（开头或结束）</description>
    </item>
    
    <item>
      <title>R中时间类型概念</title>
      <link>/md/2018-04-14-r%E4%B8%AD%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sat, 14 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-14-r%E4%B8%AD%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E6%A6%82%E5%BF%B5/</guid>
      <description>基本类型介绍 在R中，所有有关时间和日期的类(包),都可以处理日历时间(eg:2018年4月13日)，只有某些特定的类才能处理日期时间类型(eg:2018年4月13日 下午6:45)
类 处理类型 说明 强制转换 R所在包 Date类 日历日期 实际存储的为数字，是从1970年1月1日算起到该时间以天计算的一个数值.
eg: &amp;ldquo;2018-04-13&amp;rdquo; as.Date() 基本函数 POSIXct类 日期时间 实际存储的为数字，是从1970年1月1日算起到该时间以秒计算的一个数值.
eg: &amp;ldquo;2018-04-13 19:47:18 CST&amp;rdquo;
个人建议使用这个，存储数据 as.POSIXct() 基本函数 POSIXlt类 日期时间 实际存储为含有9个元素的列表,其中包括年、月、日、小时、分钟、秒。
eg: &amp;ldquo;2018-04-13 19:47:18 CST&amp;rdquo;
存储非结构化数据 as.POSIXlt() 基本函数 Date类 日历日期 同上 as_date() lubridate包 POSIXct类 日期时间 同上 as_datetime() lubridate包 difftime类 时间 实际存储的为数字，是从当天00:00:00算起到该时间以秒计算的一个数值.
eg:&amp;ldquo;00:01:25&amp;rdquo; hms::as.hms(85) lubridate包 在实际工作中，只要满足要求，尽量适用比较简单的类型，先考虑Date ，在考虑POSIXct
R中处理时间序列的包： chron ： 常用于计量经济学和时间序列分析中
lubridate： 推荐,特别适用于处理日期时间算法
mondate: 特别适用于处理以月为单位的日期，（会计和精算工作中常用）
timeDate： 很强大，对时间精度要求高的话，可以考虑
时间的基本用法 字符串转换为日期： as.Date(x ,format=&amp;quot;%m/%d/%y&amp;quot;) ,建议format参数不能省，否则有时会出错
日期转化为字符串: as.characher() 或者 format()</description>
    </item>
    
    <item>
      <title>R 语言并行化计算之foreach包</title>
      <link>/md/2018-04-08-r%E8%AF%AD%E8%A8%80%E5%B9%B6%E8%A1%8C%E5%8C%96%E8%AE%A1%E7%AE%97%E4%B9%8Bforeach%E5%8C%85/</link>
      <pubDate>Sun, 08 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-08-r%E8%AF%AD%E8%A8%80%E5%B9%B6%E8%A1%8C%E5%8C%96%E8%AE%A1%E7%AE%97%E4%B9%8Bforeach%E5%8C%85/</guid>
      <description>foreach包执行任务的核心理念与传统的apply组函数基本一致，都是与split – apply – combine一致的流程，不过foreach比传统apply组函数的优越之处在于，它可以通过调用操作系统的多核运行性能来执行并行任务，这样特别是对于I/O密集型任务而言，可以大大节省代码执行效率。
解读foreach()函数
library(&amp;#34;doParallel&amp;#34;) #加载doParallel包用于之后注册进程 library(&amp;#34;foreach&amp;#34;) #导入foreach包 ######################################################################## ########## foreach()函数主要是对原本的for循环进行并行运算 ############### ######################################################################### #############并行化格式 detectCores() #这个网上说是核数，但实际上是线程数，和真实的物理核多一倍，4核8线程 cl&amp;lt;- makeCluster(detectCores()) # 不过R中能运行满线程 ，即detectCores()返回的核数。 registerDoParallel(cl) #进行进程注册 mydata1 &amp;lt;- foreach( ..., # 并行化参数（循环参数）,当参数为两个以上时，选长度较短的循环完为止. .combine, #合并方式，default是list，“c”返回vector,cbind和rbind返回矩阵,也可以自定义函数. # &amp;#34;+&amp;#34;和&amp;#34;*&amp;#34;是対返回后的list进行同列操作 .init, #.combine函数的第一个变量,当.combine参数被具体化是才用 .final=NULL, #返回最后结果 .inorder=TRUE,#返回和原始输入相同顺序的结果 .multicombine=FALSE,#设定.combine函数的传递参数，FALSE表示其参数是2，TRUE可以设定多个参数 .maxcombine=if (.multicombine) 100 else 2, #设定.combine的最大参数 .errorhandling=c(&amp;#39;stop&amp;#39;, &amp;#39;remove&amp;#39;, &amp;#39;pass&amp;#39;),#如果循环中出现错误，对错误的处理方法 .packages=NULL,# 指定在%dopar%运算过程中依赖的package（%do%会忽略这个选项）。 .export=NULL, # 在编译函数的时候需要预先加载一些内容进去，类似parallel的clusterExport .noexport=NULL, .verbose=FALSE) ##是否打印运行信息 ) %dopar% {***} #并行的代码，也可以是相应的函数,即我们for循环的函数体 stopCluster(cl) # 结束集群 注意：平时我们大多数使用时，很多参数都选取默认状态，其中常用参数为：... 、.combine、.packages.
基本操作
library(&amp;#34;doParallel&amp;#34;) #加载doParallel包用于之后注册进程 library(&amp;#34;foreach&amp;#34;) #导入foreach包 cl&amp;lt;- makeCluster(detectCores()-1) registerDoParallel(cl) #进行进程注册 getDoParWorkers() # #查看注册了多少个核 code=function(){ x1&amp;lt;-(a + b); x2&amp;lt;-a*b; c(x1,x2); } # 并行化参数,当参数为两个以上时，选长度较短的循环完为止.</description>
    </item>
    
    <item>
      <title>RSelenium应用--京东商品</title>
      <link>/md/2018-04-07-rselenium%E5%BA%94%E7%94%A8%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81/</link>
      <pubDate>Sat, 07 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-07-rselenium%E5%BA%94%E7%94%A8%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81/</guid>
      <description>library(RSelenium) library(stringr) setwd(&amp;#34;E:\\rwork\\Rselenium&amp;#34;) ######## 初始化浏览器#### remDr &amp;lt;- remoteDriver( browserName = &amp;#34;chrome&amp;#34;, # 浏览器可以自己设置firefox、chrome、phantomjs（要配置） remoteServerAddr = &amp;#34;localhost&amp;#34;, port = 4444L) # 默认情况下，Selenium Server侦听端口为4444 remDr$open() # 打开浏览器 # remDr$getStatus() ## 使用该status方法查询远程服务器的状态。 url=&amp;#34;https://www.baidu.com/&amp;#34; remDr$navigate(url) # navigate方法打开网页，url一定要完整 ## remDr$getCurrentUrl() # 获取当前页面的url ###########################进行搜索关键词 ##### 按属性--属性值搜索 ,可以是css,xpath ,id ,属性等 对应值 webElem &amp;lt;- remDr$findElement(using = &amp;#39;css&amp;#39;, &amp;#34;#kw&amp;#34;) # 找到这个元素--进行搜索关键词 webElem$sendKeysToElement(list(&amp;#34;京东&amp;#34;,key=&amp;#34;enter&amp;#34;)) #### 获取当前页面的所有标题，每个链接的标题都包含在&amp;lt;h3 class = &amp;#34;t&amp;#34;&amp;gt;标签中。我们将h3首先访问标题 #### 注意 findElements和 findElement方法是获取一个或者多个的区别 webElems &amp;lt;- remDr$findElements(using = &amp;#39;css&amp;#39;, &amp;#34;h3.t&amp;#34;) resHeaders &amp;lt;- unlist(lapply(webElems, function(x){x$getElementText()})) # resHeaders ######################## 鼠标点击事件 webElem&amp;lt;-remDr$findElement(using = &amp;#34;css&amp;#34;,&amp;#34;#w-f80518 &amp;gt; div &amp;gt; h2 &amp;gt; a.</description>
    </item>
    
    <item>
      <title>利用RSelenium包模拟浏览器爬取网页信息</title>
      <link>/md/2018-04-06-rselenium/</link>
      <pubDate>Fri, 06 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-06-rselenium/</guid>
      <description>1.背景介绍： 现在很多网页都采用AJAX这种异步加载的网页结构，简单的页面爬取不了这些数据
例如：
2、这是需要R包&amp;mdash;RSelenium包
使用RSelenium包的准备
0、JAVA 环境的准备 ，安装是否成功可以进行xlsx包进行测试
1、Chrome驱动 下载,注意chrome驱动一定要和chrome浏览器对应 ,比如我的浏览器 65.0.3325.181 ，对应表放在文章最后,或者点击这里,,怎么查看浏览器版本，点击谷歌浏览器右上【&amp;hellip;】&amp;mdash;【帮助】&amp;ndash;【关于Google Chrome】就可以看到浏览器版本了。
2、Selenium Standalone Server下载 我用的是 selenium-server-standalone-3.11.0.jar
3、PhantomJS下载 ,无头浏览器。(这个个人需要的话就下载，我用Google浏览器就够了)
2、安装流程： 使用前的基本配置 首先，安装JAVA JDK 1.8。
然后，安装Chrome（最新版本）。
之后，把解压后的ChromeDriver.exe（最新版本）放在Chrome的安装路径下。一定要和chrome.exe放在同一个目录下面。例如
把chromedriver.exe所在目录的路径(建议放在和chrome.exe)放入环境变量中即可,
基本配置基本完成
3、RSelenium使用与实例 3.1、使用前的基础步骤 1、首先 ，打开cmd ，切换到 selenium-server-standalone-3.0.1.jar文件所在的位置，我的都在C:\RSelenium这个目录下 ，切换以后 ，运行
java -jar selenium-server-standalone-3.11.0.jar
显示 ：
或者直接在Rstudio中运行system(&#39;java -jar &amp;quot;C:/RSelenium/selenium-server-standalone-3.11.0.jar&amp;quot;&#39;,wait = FALSE)代码即可。
2、运行后，最小化，不要关闭，在打开Rstudio,
3、通过R调用Selenium Server并打开网页，对页面进行点击，选取相应条件。通过RSelenium与rvest共同爬取数据。通过 一步一步解读Rcode来解释这一过程。
3.2、案例1 浏览器的基本操作
library(RSelenium) library(stringr) setwd(&amp;#34;C:\\RSelenium&amp;#34;) ######## 初始化浏览器#### remDr &amp;lt;- remoteDriver( browserName = &amp;#34;chrome&amp;#34;, # 浏览器可以自己设置firefox、chrome、phantomjs（要配置） remoteServerAddr = &amp;#34;localhost&amp;#34;, port = 4444L) remDr$open() # 打开浏览器 remDr$getStatus()# 使用该status方法查询远程服务器的状态。 # 关闭浏览器 # remDr$quit() # 直接退出 # remDr$close() # close用于关闭当前会话，也可以用作关闭浏览器 **访问DOM中的元素 **</description>
    </item>
    
    <item>
      <title>R语言字符处理---基本函数</title>
      <link>/md/2018-04-05-r%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86---%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-05-r%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86---%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/</guid>
      <description>R语言字符处理&amp;mdash;基本函数 函数 说明 Encoding(x) Encoding(x) &amp;lt;- value enc2native(x) enc2utf8(x) 读取或设置字符向量的编码
常结合iconv(x, from = &amp;ldquo;&amp;rdquo;, to = &amp;ldquo;&amp;quot;)函数使用
注意：Encoding(x) &amp;lt;- value 这是一种赋值函数 nchar(x, type = &amp;ldquo;chars&amp;rdquo;, allowNA = FALSE, keepNA = NA)
nzchar(x, keepNA = FALSE) nchar()返回字符长度
nzchar()判断是否空字符
keepNA为真是NA保留，不计入计数
对于缺失值NA，nchar和nzchar函数默认是字符数为2的字符串。
对于NULL，nchar和nzchar函数会忽略掉。 substr(x, start, stop)
substring(text, first, last = 1000000L)
substr(x, start, stop) &amp;lt;- value
substring(text, first, last = 1000000L) &amp;lt;- value 提取或替换字符向量的子字段，substring同substr功能一样 strtrim(x, width) 按显示宽度截断字符串 paste (&amp;hellip;, sep = &amp;quot; &amp;ldquo;, collapse = NULL)</description>
    </item>
    
    <item>
      <title>R语言字符处理函数包---stringr包</title>
      <link>/md/2018-04-05-r%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E5%A4%84%E4%B9%8Bstringr%E5%8C%85/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-05-r%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E5%A4%84%E4%B9%8Bstringr%E5%8C%85/</guid>
      <description>1.stringr介绍 stringr包被定义为一致的、简单易用的字符串工具集。所有的函数和参数定义都具有一致性，比如，用相同的方法进行NA处理和0长度的向量处理。
字符串处理虽然不是R语言中最主要的功能，却也是必不可少的，数据清洗、可视化等的操作都会用到。对于R语言本身的base包提供的字符串基础函数，随着时间的积累，已经变得很多地方不一致，不规范的命名，不标准的参数定义，很难看一眼就上手使用。字符串处理在其他语言中都是非常方便的事情，R语言在这方面确实落后了。stringr包就是为了解决这个问题，让字符串处理变得简单易用，提供友好的字符串操作接口。
2.stringr的API介绍 stringr包常用的字符串的处理以str_开头来命名，方便更直观理解函数的定义。我们可以根据使用习惯对函数进行分类：
字符串拼接函数 函数 说明 R Base中对应函数 str_c()
str_join() 同str_c() 字符串拼接 paste(),paste0() str_trim()) 去掉字符串的空格和TAB(\t) str_pad() 用pad参数填充字符串的长度，长度自己设定 str_dup() 复制字符串 str_wrap() 控制字符串输出格式 strtrim() str_sub()
str_sub() &amp;lt;- value 截取字符串
抽取或替换正则表达式匹配子串 regmatches()
regmatches() &amp;lt;- value 字符串计算函数 函数 说明 R Base中对应函数 str_count() 字符串计数，返回指定匹配出现的次数 str_length() 返回字符的长度 nchar() str_sort() 对字符值进行排序 str_order() 字符串索引排序， 字符串匹配函数 函数 说明 R Base中对应函数 str_split()
str_split_fixed() 同上 按照模式分割字符串 strsplit() str_match()
str_match_all() 从字符串中提取首个匹配组
str_replace
str_replace_all 替换首个匹配模式
sub()
gsub() str_replace_na() 把NA替换为NA字符串 str_locate()
str_locate_all() 返回首个匹配模式的字符的位置</description>
    </item>
    
    <item>
      <title>data.table -- 2基本概念</title>
      <link>/md/2018-01-17-datatable2/</link>
      <pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-01-17-datatable2/</guid>
      <description>data.table基本概念和其余函数&amp;mdash;还需要修改 set* 函数族 会改变原有的数据，没有返回值，在data.table里，操作符&amp;quot;:=&amp;quot;和所有的以set开头函数（比如setkey,setorder,setname等）一样，它们都会更新输入的原数据。
library(data.table) iris_dt = data.table(iris) # setnames(DT,oldnames,newnames) # 改变DT的列名oldnames,newnames为向量即变量 #改变列的顺序 col_names = colnames(iris_dt) setcolorder(iris_dt,col_names[5:1]) # 更改某行某列的值,即更新元素的值 set(iris_dt,1,1,NA)# 更改1行1列的值为NA 1、键（主键）的概念 data.table从来不使用行名。data.table类似有行名的形式为1:，2: , ... 主键会对筛选的列进行重排序 我们把data.table数据中的行名叫做键（或主键），他类似于python的字典，使用键值对类型查找数据，键要求唯一，每一行有且只有一个键。但是R中的键可以用多个甚至可以重复，键就相当于索引，通过键进行数据的查找 setkey() 和 setkeyv()可以直接更新输入的data.table，就和上一讲中的操作符&amp;quot;:=&amp;ldquo;一样。它们没有返回值。 这个主键和其它语言不一样，例如python的键，唯一，在r中任意列都能使用setkey()来设置主键 library(data.table) mtcars_dt &amp;lt;- data.table(mtcars) # 可以看出mtcars数据集中的行名没有了，替而代之为1: ，2: # 若想保留行名，设置keep.rownames = T，当keep.rowname＝&amp;#34;new&amp;#34;时，列名改为new即可 mtcars_dt &amp;lt;- data.table(mtcars,keep.rownames = T)#默认创建一个叫做 rn的列，并且将行名赋值给这一列。 mtcars_dt 1.2、设置／获取／使用主键 怎么将数据中的某一列设置为主键呢？&amp;mdash;setkey()函数
setkey(DT, key) 将DT中的key列设置为主键，但是类行名 1:，2:,&amp;hellip;,不会发生改变, 上面等价 setkeyv(DT, &amp;quot;key&amp;quot;) ，也将DT中的key列设置为主键 一旦将某一列设置成data.table的主键，就可以在参数i里指定 .()来subset那些主键了(就可以进行行筛选了)。我们还是用mtcars数据集，我们增加一个新列new mtcars_dt &amp;lt;- data.table(mtcars) mtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间 setkey(mtcars_dt,new) mtcars_dt # 类似行名并没有发生改变， mtcars_dt[.</description>
    </item>
    
    <item>
      <title>data.table -- 1基本函数</title>
      <link>/md/2018-01-16-datatable1/</link>
      <pubDate>Tue, 16 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-01-16-datatable1/</guid>
      <description>data.table本质上是一个list，它们的列包含的元素个数都相同。
1、数据的读写 1.1数据读入－－fread 选其常用的参数如下：
fread(input,na.strings=&amp;#34;NA&amp;#34;, file, stringsAsFactors=FALSE,encoding=&amp;#34;unknown&amp;#34;, ...) input 入的文件对象，fread函数可以自动判断分隔符类型，自动判断首行是否是列标题，同时默认读入时字符型变量不会变为因子型。也可也从网页读取数据 na.strings,对NA的解释； file文件路径，再确保没有执行shell命令时很有用，也可以在input参数输入; stringsASFactors是否转化字符串为因子， encoding，默认&amp;quot;unknown&amp;quot;，其它可能&amp;quot;UTF-8&amp;quot;或者&amp;quot;Latin-1&amp;quot;，不是用来重新编码的，而是允许处理的字符串在本机编码; showProgress = T 显示进度条 integer64 当数据列中有大于2 ^ 31的整数,可能会丢失精度 quote 对带双引号的字符添加转义,在R中正常显示,但是输出时,可能会引起成倍的双引号,因此建议使用fwrite时,设置该参数quote = FALSE 1.2数据写入－－fwrite fwrite(x, file = &amp;#34;&amp;#34;, append = FALSE, na = &amp;#34;&amp;#34;, row.names = FALSE, col.names = TRUE,logicalAsInt = FALSE, ...) x,比如data.frame和data.table等R的对象； file，输出文件名,&amp;ldquo;&amp;ldquo;意味着直接输出到操作台； append，如果TRUE,在原文件的后面添加；默认删除原来文件的数据，重新存储。 na,na值的表示，默认&amp;rdquo;&amp;quot;； row.names，是否写出行名，因为data.table没有行名，所以默认FALSE； col.names ，是否写出列名，默认TRUE，如果没有定义，并且append=TRUE和文件存在，那么就会默认使用FALSE; logicalAsInt,逻辑值作为数字写出还是作为FALSE和TRUE写出； 1.3 数据框转为data.table 对于数据的处理，data.table包提供了一个非常简洁的通用格式：DT[i,j,by]，
其中i控制列, j控制列, by控制分组. 上述表达式的意思是: 对于数据集DT，先选取子集行i, 然后通过by分组计算j。i设定数据的选取条件，j设定结果的计算方式，by设定数据的分组情况。通过这个，我们可以在一行代码中很方便地完成处理过程。首先需要把数据变为data.table类型 library(data.table) library(magrittr) ### 方法一: 赋值转换 mtcars_dt &amp;lt;- data.</description>
    </item>
    
    <item>
      <title>R软件常见问题</title>
      <link>/md/2018-01-07-%E4%BD%BF%E7%94%A8r%E8%BD%AF%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-01-07-%E4%BD%BF%E7%94%A8r%E8%BD%AF%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>1、读取数据编码问题 读取csv文件出现中文乱码方案，增加编码格式参数
read.csv(trainPath,header=TRUE,stringsAsFactors=TRUE,encoding = &amp;#34;UTF-8&amp;#34;) 保存csv文件中出现乱码，编码格式参数
write.csv(outp, file = path, quote = F, fileEncoding = &amp;#34;UTF-8&amp;#34;) #存储utf-8也乱码，我的电脑有时会发疯，有时又不会 source 加载R脚本中文乱码
source(&amp;#34;core.R&amp;#34;,encoding=&amp;#34;utf-8&amp;#34;) RStudio中脚本中文乱码，编码格式设置：tools -&amp;gt; global option&amp;hellip;., 设置为UTF-8，最后，在打开文件的时候，选择File -&amp;gt; Reopen with encoding菜单，选择我们使用UTF-8编码打开文件，这样子就可以正确地显示中文了。
R语言环境的显示问题
sessionInfo() Sys.getlocale() Sys.setlocale(category = &amp;#34;LC_ALL&amp;#34;,local=&amp;#34;us&amp;#34;) Sys.setlocale(category = &amp;#34;LC_ALL&amp;#34;,local=&amp;#34;chinese&amp;#34;) 2、保存数据编码问题(win中) 由于用Rstudio设置了保存的编码都用UTF-8，所以在保存文件时（特别是csv文件），经常遇到乱码的现象，比如使用data.table:::fwrite()、自带的write.csv()、readr:::write_csv()都乱码
产生的原因：
因为excel打开文件时默认使用unicode的编码方式（还有的网友说是默认以ANSI编码方式打开，待考）。在Unicode基本多文种平面定义的字符（无论是拉丁字母、汉字或其他文字或符号），一律使用2字节储存。恰恰utf-8是1字节的存储方式，所以excel直接打开时会出现乱码。
解决办法：
**方法1、数据导入&amp;ndash;**不建议
打开 Excel，执行“数据”-&amp;gt;“自文本”，选择 CSV 文件，出现文本导入向导，选择“分隔符号”，下一步，勾选“逗号”，去掉“ Tab 键”，下一步，完成，在“导入数据”对话框里，直接点确定。导入之后，所有汉字显示正常，乱码问题解决。
万一这个文本里面的有逗号，巧好分割时候是逗号（csv文件是以逗号进行存储的）,这就会对不齐了，产生新的问题
方法2、先另存再打开
使用记事本打开CSV文件，“文件”-&amp;gt;“另存为”，编码方式选择ANSI，保存完毕后，用EXCEL打开这个文件就不会出现乱码的情况。
不会乱码以后选择另存为excel
方法3、用readr:::write_excel_csv()函数解决
直接用write_excel_csv()这个函数就可以解决上述问题
3、加载java问题 首先下载java ，把java加入环境变量，测试是否安装成功，在cmd命名下输入: java -version,返回
C:\Users\zsc&amp;gt;java -version java version &amp;#34;1.8.0_151&amp;#34; Java(TM) SE Runtime Environment (build 1.</description>
    </item>
    
    <item>
      <title>dplyr -- 1基本函数简介</title>
      <link>/md/2018-01-01-dplyr/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-01-01-dplyr/</guid>
      <description>0、dplyr初始 由于R语言每一个步骤没有赋值的话，是不会改变原有的数据，都是建立一个新的数据。原有数据不改变。
dplyr::tbl_df(iris)： 将数据转化为tbl类。只会显示适合屏幕大小的数据：
dplyr::glimpse(iris)： tbl数据的信息密集概括。 类似str()函数
dplyr::%&amp;gt;%： 将左边的对象作为第一个参数（或参数 .）传递到右边的函数中。利用%&amp;gt;%进行“Piping”管道操作增强了代码的可读性，
x %&amp;gt;% f(y) 相当于 f(x, y) y %&amp;gt;% f(x, ., z) 相当于 f(x, y, z ) 1、filter 行过滤 **filter(iris, Sepal.Length &amp;gt; 7) ：**抽取符合逻辑条件的数据记录。 **distinct(iris) ：**删除重复记录。 distinct(iris, Species) 保留iris某一列的唯一值 **sample_frac(iris, 0.5, replace = TRUE) ：**随机选取部分数据(占总体的0.5)记录。 **sample_n(iris, 10, replace = TRUE) ：**随机选取n条数据记录。 **slice(iris, 10:15) ：**通过位置选取数据记录。 **top_n(storms, 2, date) ：**选取并排列前n条数据记录 （若为分组数据则按组排序） 2、select 列过滤 rename(.data, ...) rename_all(.tbl, .funs = list(), ...) rename_if(.tbl, .predicate, .funs = list(), .</description>
    </item>
    
    <item>
      <title>tibble包的列和行名相互转换以及添加行和列</title>
      <link>/md/2017-12-31-tibble%E5%8C%85%E7%9A%84%E5%88%97-%E8%A1%8C%E5%90%8D%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/md/2017-12-31-tibble%E5%8C%85%E7%9A%84%E5%88%97-%E8%A1%8C%E5%90%8D%E8%BD%AC%E6%8D%A2/</guid>
      <description>1、列与行名相互转化 tibble包：
has_rownames(df)：检查是否存在行名
remove_rownames(df) ： 移除行名
rownames_to_column(df, var = &amp;ldquo;rowname&amp;rdquo;) ： 行名变为某列
rowid_to_column(df, var = &amp;ldquo;rowid&amp;rdquo;)： 行名变为某列,只能变为数字,个人不推荐 column_to_rownames(df, var = &amp;ldquo;rowname&amp;rdquo;) ： 某列变为行名，并删除某列,要求这个列值唯一
library(tibble) head(mtcars) has_rownames(mtcars) #检查是否存在行名 new_mtcars=rownames_to_column(mtcars, var = &amp;#34;new_col&amp;#34;) #行名变为某列,行名此时被移除 head(new_mtcars) has_rownames(rownames_to_column(mtcars, var = &amp;#34;new_col&amp;#34;)) has_rownames(rowid_to_column(mtcars, var = &amp;#34;new_col&amp;#34;)) df=remove_rownames(mtcars)#： 移除行名 head(df) column_to_rownames(new_mtcars, var = &amp;#34;new_col&amp;#34;)# 某列变为行名，并删除某列,要求这个列值唯一 2、添加行与列 添加行：
add_row(.data, &amp;hellip;, .before = NULL, .after = NULL) 添加列：
add_column(.data, &amp;hellip;, .before = NULL, .after = NULL) .before 指添加在第n行(列)，默认在最后 .</description>
    </item>
    
    <item>
      <title>数据集划分—-训练集和测试集方法</title>
      <link>/md/2017-11-13-%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/md/2017-11-13-%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86/</guid>
      <description>1.随机采样sample()&amp;mdash;例：iris数据 sample(x, size, replace = FALSE, prob = NULL) Index = sample(nrow(iris),size = nrow(iris)*0.8) trian_data = iris[Index,] #作为训练集 test_data = iris[-Index,] #作为测试集 类似的还有dplyr包中的sample_n函数
sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL)
2. carte包&amp;ndash;createDatePartition 来进行分区抽样 inTrain =createDataPartition(响应变量y ,p=0.8,list=FALSE)
inTrain : 产生对应数据集行的索引 y 要分类或预测的变量, p 对应y的数据个数的概率 library(caret) set.seed(2012) #随机种子 Index =createDataPartition(iris$Species,p=0.8,list=FALSE) # 不知道为何？ iris[,5]不能使用 trian_data = iris[Index,] #作为训练集 test_data = iris[-Index,] #作为测试集 # 同样用上面第一种方法 产生数据集即可 3. dplyr::sample_frac()函数 sample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .</description>
    </item>
    
    <item>
      <title>R语言文件目录相关操作</title>
      <link>/md/2017-04-08-r%E4%B8%AD%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 08 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/md/2017-04-08-r%E4%B8%AD%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</guid>
      <description>1. 文件系统介绍 R语言对文件系统的操作，包括文件操作和目录操作，函数API都定义在base包中。
2. 目录操作 2.1 查看目录
查看当前目录下的子目录。
setwd() #设定某个目录为当前目录 getwd() # 当前的目录 list.dirs() # 查看当前目录的子目录 参数详见dir() dir() #查看当前目录的子目录和文件。 dir(path=&amp;#34;C:/windows&amp;#34;)#查看指定目录的子目录和文件 dir(path=&amp;#34;C:/windows&amp;#34;,all.files=TRUE)# 列出目录下所有的目录和文件，包括隐藏文件 dir(path=&amp;#34;C:/windows&amp;#34;,pattern=&amp;#39;^R&amp;#39;)#只列出以字母R开头的子目录或文件 file.info(&amp;#34;.&amp;#34;) # 查看当前目录权限 2.2 创建目录
dir.create(&amp;#34;your dir&amp;#34;) # 在当前目录下，新建一个目录 dir.create(path=&amp;#34;a1/b2/c3&amp;#34;,recursive = TRUE) #递归创建一个3级子目录./a1/b2/c3，直接创建会出错 2.3 检查目录是否存在
system(&amp;#34;tree&amp;#34;) # 通过系统命令查看目录结构 file.exists(&amp;#34;./a1&amp;#34;) # 查看某个目录是否存在,可以多层次调用目录 2.4 检查目录的权限
df&amp;lt;-dir(full.names = TRUE) #获取当前目录的所有目录(不含子目录)和文件名（含后缀） file.access(df, model=0) == 0 # 检查文件或目录是否存在，mode=0 # 检查文件或目录是否可执行，mode=1，目录为可以执行 # 检查文件或目录是否可写，mode=2 # 检查文件或目录是否可读，mode=4 2.5修改目录权限。
Sys.chmod(&amp;#34;./create&amp;#34;, mode = &amp;#34;0555&amp;#34;, use_umask = TRUE) # 修改目录权限，所有用户只读 2.</description>
    </item>
    
    <item>
      <title>R语言与可视化</title>
      <link>/md/2017-01-30-r%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/md/2017-01-30-r%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</guid>
      <description>R可视化 静态图形 动态图形 静态图形 基础统计图 grDevice Lattile Grid ggplot2 地图 ggmap ggplot2 maptools maps sp 网络 igraph linkcomm statmet 特殊图形 基因组的(ggbio……) 动态图形 非浏览器平台 rgl rggobi(ggobi) animation(animation) RGtk2 iplots 动态图形 浏览器平台 ggvis rCharts(http://ramnathv.github.io/rCharts/) recharts (https://recharts.cosx.org/) plotly(https://plotly-r.com/, https://plot.ly/r/) googlevis Remap(https://github.com/Lchiffon/REmap) htmlwidgets 框架 leaflet(地图) dygraphs (时间序列) diagrammeR(diagram) – 化学结构 network3D (网格) DT (表格) threeJS (3D数据展示) </description>
    </item>
    
    <item>
      <title>Rweka包解读</title>
      <link>/md/2015-11-16-rweka/</link>
      <pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/md/2015-11-16-rweka/</guid>
      <description>1. 数据输入和输出 WOW()：查看Weka函数的参数。 Weka_control()：设置Weka函数的参数。 read.arff()：读(ARFF)格式的数据。一般的数据需要用这两个函数（先写再读）进行转换成（arff）格式的数据 write.arff()：将数据写入Weka Attribute-Relation File Format (ARFF)格式的文件。 2. 数据预处理 Normalize()：无监督的标准化连续性数据,即min-max标准化。对于字符、逻辑、因子变量跳过，只对连续数据标准化
Discretize()：用MDL(最小描述长度)方法，有监督的离散化连续性数值数据。感觉用处不大，把连续的数据全离散成“all”字符
3. 分类和回归 IBk()：k最近邻分类，用法和LBR一样
LBR()：naive Bayes法分类
RWeka包中的IBK函数实现knn算法 * model=IBk(formula, data, subset, na.action,control = Weka_control(), options = NULL) + formula:公式，分类变量~特征，和回归一样 + data : 训练数据集,必须为*.raff格式的数据,对于R中的数据， + 可以先把某个对象先用write.arff(iris,&amp;#39;iris.arff&amp;#39;)写成raff文件格式 + 再次用read.arff(&amp;#34;iris.arff&amp;#34;)读入R内存中即可 + control:参数控制 control=Weka_control(K= 22,X = TRUE) + X K都为大写，表示自动选取1：K=22里面最适合的K近邻分类 * evaluate_Weka_classifier(object, newdata = NULL, cost = NULL, numFolds = 0, complexity = FALSE, class = FALSE, seed = NULL, ...) + object: 一个Weka_classifier对象,Rweka建立的分类对象模型 + newdata: 测试数据，若为省略或为0 ，则为训练数据 + numFolds： k-交叉验证 J48()：C4.</description>
    </item>
    
  </channel>
</rss>
