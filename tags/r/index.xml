<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on zsc</title>
    <link>/tags/r/</link>
    <description>Recent content in R on zsc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 16 Aug 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/r/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>R动画</title>
      <link>/md/2020-08-16-r%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-08-16-r%E5%8A%A8%E7%94%BB/</guid>
      <description>R 动画 动画的本质是有n张图片进行拼接,到达欺骗人的眼睛.
在R中有常见的有两个包.
gifski 包, 搭配 rmd 文件使用, gganimation 包 gifski 包 安装 gifski 包：
xfun::pkg_load2(&amp;#39;gifski&amp;#39;) 再用代码段选项 animation.hook=&#39;gifski&#39;，如:
```{r, animation.hook=&amp;#39;gifski&amp;#39;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&amp;#39;red&amp;#39;, &amp;#39;yellow&amp;#39;), labels = NA) } ``` 则会直接生成gif动画
https://slides.yihui.org/2020-bearclub-rmarkdown.html#7
gganimation 包 见官网</description>
    </item>
    
    <item>
      <title>画函数图像--R语言</title>
      <link>/md/2020-08-15-%E7%94%BB%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8Fr%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Sat, 15 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-08-15-%E7%94%BB%E5%87%BD%E6%95%B0%E5%9B%BE%E5%83%8Fr%E8%AF%AD%E8%A8%80/</guid>
      <description>据我了解, 计算机软件中画的函数图像大概有两种方法:
方法一: 该图像有一系列密集点组成, 已达到欺骗人们的眼睛.感觉认为是连续的. 方法二: 为了解决方法一种的问题,把每两个点之间用直线连接已达到连续的状态 在本文中我们将利用R语言来画函数图像&amp;mdash;- 重点以ggplot2来展示
1. $y = f(x)$ 的函数图像 比如:
$$ \begin{aligned} y &amp;amp;= sin(x),\ y &amp;amp;= cos(x), \ y &amp;amp;= \dfrac{1}{1+e^{(-x)}},\ y &amp;amp;= x^2 . \end{aligned} $$
这是我们中学最常见的函数.
方法一: curve()画函数图像 所用函数调用格式
curve(expr, from = NULL, to = NULL, n = 101, add = FALSE, type = &amp;#34;l&amp;#34;, xname = &amp;#34;x&amp;#34;, xlab = xname, ylab = NULL, log = NULL, xlim = NULL, ...) # expr：函数名称或一个关于变量x的函数表达式； # from，to：表示绘图的起止范围； # n：一个整数值，表示x取值的数量； # add：是一个逻辑值，当为TRUE时，表示将绘图添加到已存在的绘图中； # type：与plot函数中type含义相同 #定义公式 sigmoid &amp;lt;- function(x) 1/(1+exp(-x)) #画sigmid图像 curve(sigmoid,-10,10) #画sin(x)函数图像 curve(sin,-10,10) # 画y=x^2的图像 curve(x^2,-10,10) 方法二: ggplot2 首先介绍两个映射</description>
    </item>
    
    <item>
      <title>latex 缩写期刊</title>
      <link>/md/2020-08-11-latex%E7%BC%A9%E5%86%99%E6%9C%9F%E5%88%8A/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-08-11-latex%E7%BC%A9%E5%86%99%E6%9C%9F%E5%88%8A/</guid>
      <description>以下软件对参考文献都不能完美的满足我的要求, 因此可以结合不同软件的优势,达到最后的效果
1. zotero 设置—首选项—bitter bibtex —export — 最下面有一个期刊缩写,选购就能导出缩写的期刊名了
特点: 使用该软件, 系统自带的期刊缩写对照表很少, 且不能添加对照表, 不会自动更新bib文件 可以按照key键的顺序(升序) 导出bib数据库, 只需导出时选中[biter bibtex]选项即可 也可以安装以前的方式导出bib数据库, 只需导出时选中[bibtex]选项即可 2. Mendeley 特点: 默认情况下, 联网会自动更新bib数据库, 这一点很烦(for me), 因此可以直接断网使用该软件 期刊缩写很好,内置了很多比较全的期刊缩写.但某些期刊仍不全面,且缩写的格式看不见 3. Jabref软件 特点:
内置的期刊缩写相对较少, 但是可以手动添加期刊缩写列表(官网有), 就是电脑卡
由于bib文件中使用的是\&amp;amp; , 而jabref软件中默认使用&amp;amp;, 这样对照表中可能不会存在相应的缩写
不能导出按照key键顺序导出相应的bib文件
使用期刊缩写时,首先使用展开期刊全名,才去缩写,不然有可能找不到,
不会自动更新bib文件
下面是使用期刊缩写步骤, 先管理期刊缩写名(选择使用哪种类型的对照表),在进行期刊缩写
4. 自用软件包journalabbr 利用Jabref软件提供了大量的期刊缩写列表https://github.com/JabRef/abbrv.jabref.org,但是在Jabref软件中使用经常死机. 借助 pandoc , 该软件提供了大量命令参数, 感兴趣的可以去探索, 而xieyihui 通过使用*.Rmd文件进行了封装(前提要安装并了解R + Rstudio), 个人在巨人的肩上, 进行了简单封装,提供了一个R包journalabbr提供了一个本地app 和一个在线app, 解决了Jabref缩写期刊时遇到的缺点. 该app主要功能: 提供期刊缩写, 美化bib数据库文件以及提供类似bst文件那样批量生成一个完整的 thebibliography 环境. app截图如下: </description>
    </item>
    
    <item>
      <title>R&amp;shiny自动截图</title>
      <link>/md/2020-05-18-shiny%E6%88%AA%E5%9B%BE/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-05-18-shiny%E6%88%AA%E5%9B%BE/</guid>
      <description>利用webshot 进行截图 library(shiny) library(ggplot2) histogram &amp;lt;- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) { df &amp;lt;- data.frame( x = c(x1, x2), g = c(rep(&amp;#34;x1&amp;#34;, length(x1)), rep(&amp;#34;x2&amp;#34;, length(x2))) ) ggplot(df, aes(x, fill = g)) + geom_histogram(binwidth = binwidth) + coord_cartesian(xlim = xlim) } ui &amp;lt;- fluidPage( fluidRow( column(3, numericInput(&amp;#34;lambda1&amp;#34;, label = &amp;#34;lambda1&amp;#34;, value = 3), numericInput(&amp;#34;lambda2&amp;#34;, label = &amp;#34;lambda2&amp;#34;, value = 4), numericInput(&amp;#34;n&amp;#34;, label = &amp;#34;n&amp;#34;, value = 1e4, min = 0), # 增加一个按钮 actionButton(&amp;#34;simulate&amp;#34;, &amp;#34;Simulate!</description>
    </item>
    
    <item>
      <title>创建属于自己的rmarkdown模板文件</title>
      <link>/md/2020-05-18-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84rmd%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-05-18-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84rmd%E6%A8%A1%E6%9D%BF/</guid>
      <description>rmarkdown模板文件的创建 &amp;mdash;- 修改prettydoc模板
下载链接: zscbeautiful
下载下来后, 把css和html 分别放在对应的目录中替换即可
Tip: 我的mac路径为/Library/Frameworks/R.framework/Versions/4.0/Resources/library/prettydoc/ , 只需把下载下来的文件进行替换即可
创建模板的步骤: 新建文件 &amp;mdash;&amp;gt; R mardown &amp;mdash;&amp;gt; From Template
如图:
参考: https://cosx.org/2019/10/prettydoc-internals-ljj/</description>
    </item>
    
    <item>
      <title>基本绘图中添加指定中文字体</title>
      <link>/md/2020-03-10-r%E8%AF%AD%E8%A8%80%E7%BB%98%E5%9B%BE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/md/2020-03-10-r%E8%AF%AD%E8%A8%80%E7%BB%98%E5%9B%BE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</guid>
      <description>基本绘图中添加指定中文字体 方法一: 使用par(family=&#39;STKaiti&#39;) , 方法二: 直接在画图函数后添加family 参数指定字体,在R.3.6.x 已经不可以了 barplot(df[sex == &amp;#39;男&amp;#39;,table(Year)],main = &amp;#34;男性条形统计图&amp;#34;,family = &amp;#39;Songti SC&amp;#39;) 方法三: 使用showtext包,需要xquartz软件,可以使用brew cask install xquartz library(showtext) #使用下面的函数查看所有字体,选择中文字体添加 font_files() showtext_auto(enable = TRUE) font_add(&amp;#39;Songti&amp;#39;, &amp;#39;Songti.ttc&amp;#39;,&amp;#39;STKaiti&amp;#39;,&amp;#39;STXihei&amp;#39;) #添加中文字体 quartz(family = &amp;#34;STXihei&amp;#34;) #可以把STXihei替换成任意想要的字体，如&amp;#39;Songti&amp;#39;, &amp;#39;Songti.ttc&amp;#39;,&amp;#39;STKaiti&amp;#39;等 方法四: extrafontdb 软件包 方法五: ggplot2绘图中添加指定中文字体 library(ggplot2) p = ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, col = Species)) + geom_point() p = p + labs(title = &amp;#34;iris数据集&amp;#34;) p = p + theme(plot.title = element_text(hjust = 0.</description>
    </item>
    
    <item>
      <title>R中常用的批处理操作</title>
      <link>/md/2019-11-19-r%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-11-19-r%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</guid>
      <description>批量重命名文件名 setwd(&amp;#39;/Users/zsc/Desktop/音乐mp3/&amp;#39;) library(stringr) oldname = list.files(pattern = &amp;#39;.*mp3&amp;#39;) newname = str_extract(d,&amp;#39;.*(?=158)&amp;#39;) df = data.frame(oldname = oldname, newname = newname) df file.rename(df$oldname, df$newname) 批量统计 pdf 的页数 library(qpdf) setwd(&amp;#39;/Users/zsc/Desktop/pdf/&amp;#39;) d = list.files() d d1 = str_extract(d,&amp;#39;.*?.pdf$&amp;#39;) library(purrr) map_dbl(d1, pdf_length) map_dbl(d1, pdf_length) %&amp;gt;% sum() 移除latex生成的临时文件 p = getwd() cat(p,&amp;#39;\n&amp;#39;) t = &amp;#39;*.aux|*.bbl|*.bcf|*.blg|*.log|*.xml|*.out|*.spl|*.synctex.gz&amp;#39; del = list.files(path = p,pattern = t) file.remove(del) </description>
    </item>
    
    <item>
      <title>MATLAB 与 R 在排序上的区别</title>
      <link>/matlab/2019-11-15-matlab-r-rank/</link>
      <pubDate>Fri, 15 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/matlab/2019-11-15-matlab-r-rank/</guid>
      <description>MATLAB 与 R 在排序上的区别 R 中的 rank , 返回一个向量的秩 R语言排序有几个基本函数： sort()；rank()；order() sort（）是对向量进行从小到大的排序 rank（）返回的是对向量中每个数值对应的秩 order（）返回的值表示位置，依次对应的是向量的最小值、次小值、第三小值......最大值 &amp;gt; data=c(5,6,8,2,4,9) &amp;gt; sort(data) [1] 2 4 5 6 8 9 &amp;gt; rank(data) % 秩,即排序后的位置,比如 data 中的第一个元素 5,在升序排序中是占第 3 个位置,所以返回 3. [1] 3 4 5 1 2 6 &amp;gt; order(data) [1] 4 5 1 2 3 6 MATLAB [y , index] = sort(x); y 把 x 排列升序后的结果 % 类似 R 中的 sort index 为 x 的秩 % 类似 R 中的 order tiedrank(data) % 类似 R 中的 rank, 返回平均秩, ans = 3 4 5 1 2 6 &amp;gt;&amp;gt; data=[5,6,8,2,4,9]; [y, index] =sort(data) y = 2 4 5 6 8 9 index = 4 5 1 2 3 6 有 y == data(index) &amp;gt;&amp;gt; tiedrank(data) ans = 3 4 5 1 2 6 tiedrank([10 20 30 40 20]) % 返回平均秩 ans = 1 2.</description>
    </item>
    
    <item>
      <title>非线性规划2</title>
      <link>/md/2019-06-24-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</link>
      <pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-06-24-%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</guid>
      <description>Rsolnp 非线性规划问题
$$ \begin{align} \min \quad &amp;amp; f(x)\ \text { s.t. } &amp;amp; \begin{cases} {g(x)=0} \{l_{h} \leq h(x) \leq u_{h}} \ {l_{x} \leq x \leq u_{x}} \end{cases} \end{align}
$$
其中, $f(x),g(x),h(x)$ 都是光滑函数,
solnp(pars, fun, eqfun = NULL, eqB = NULL, ineqfun = NULL, ineqLB = NULL, ineqUB = NULL, LB = NULL, UB = NULL, control = list(), &amp;hellip;)
pars : 初始值(向量),
fun : 最小化的目标函数值，输入为pars参数，输出为一个单一值,等价上述问题的f(x)
eqfun : (可选) 等式约束(左边) ，等价与上述问题的 g(x)</description>
    </item>
    
    <item>
      <title>动态可视化如此简单</title>
      <link>/md/2019-05-26-dongtaikeshihua/</link>
      <pubDate>Sun, 26 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-05-26-dongtaikeshihua/</guid>
      <description>动态可视化如此简单 不用任何代码，只需要知道你画什么图，需要什么数据格式，就可以画出漂亮的动态图了，并且有每种可视化都有相应数据案例，很方面。
由于是国外的网站，可能有点慢。
网站： https://app.flourish.studio/templates
可以参考这篇微信文章： https://mp.weixin.qq.com/s/aQfpyVtmjDp8kmzce3k11w
这个非常方便的可以嵌入到网页上去，
直接复制粘贴到markdown即可
如果要进行数据分析可视化 也可以使用IBM Watson Analystics，这个画热力地图非常方面</description>
    </item>
    
    <item>
      <title>R结合C&#43;&#43;</title>
      <link>/md/2019-05-24-randc/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-05-24-randc/</guid>
      <description>1. R结合C++ 首先要配置好R和C++的环境，在R官网中分别有不同操作系统的环境配置条件，按照下载R软件的步骤，在下载R软件页面有相应的配置说明。如果是mac系统也可以参考这篇文章：macOS
基本的用法可以参考：
http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/rcpp.html
个人建议要写c++ 代码给R软件使用，建议不要混合编程，我只是简单的实验过，这样会降低代码运行的效率，甚至，可能比R本身的运算还慢。
基本的c++ 大概能写一些简单的循环运算，但要涉及比较复杂的矩阵运算此时需要额外的库，不过不怕麻烦你自己也可以用c++写，这里推荐使用Armadillo 库，语法和MATLAB很相似，上手很快。
由于查资料发现，Armadillo 被RcppArmadillo包给封装了，但基本没有对其做任何更改，所以你只需要简单的引入相应的Rcpp环境，就能简单的写c++了，再次说明，c++中最好不要混写R代码。
CSDN上有关Armadillo库的介绍，个人觉得还不错，https://blog.csdn.net/jnulzl/article/details/46808515
c++ 并行运算对比 以及RcppArmadillo包的使用，如下，先做总结，推荐使用feature.apply包来并行c++代码，虽然有时候没有C++ openMP快，但是基本上符合人们需求，而且feature.apply包使用起来很简单，相对于其他R并行计算的包，不出错，记得使用doParallel包来并行C++总是出错，所以推荐feature.apply并行。
2. R运行速度对比 2.1 C++ 加上 feature.apply 并行 把下面的代码存为sample_c.cpp，然后运行Rcpp::sourceCpp(&#39;sample_c.cpp&#39;)即可
sample_mat ： 随机构造n阶正互反判断矩阵 eig_max： 求矩阵的最大特征值 veig_max(int n,int k =10000): 求k个n阶的最大特征值，返回一个向量。 // [[Rcpp::depends(RcppArmadillo)]] #include &amp;lt;RcppArmadillo.h&amp;gt; #include &amp;lt;Rcpp.h&amp;gt; using namespace Rcpp; using namespace arma; // [[Rcpp::export]] mat sample_mat(int n) { // 第一步： 随机构造n阶正互反判断矩阵 vec P = {1,2,3,4,5,6,7,8,9,1/2.0,1/3.0,1/4.0,1/5.0,1/6.0,1/7.0,1/8.0,1/9.0}; vec v = randu&amp;lt;vec&amp;gt;(0.5*n*(n-1)); //声明一个向量，并赋予随机值 v *= 17; v = floor(v); mat A(n,n); // 声明一个n*n的矩阵 int i = 0,j = 0,k=0,temp = 0; for(i = 0; i&amp;lt;n;i++){ for(j =0; j&amp;lt;n;j++){ if( i &amp;gt;j){ temp = static_cast&amp;lt;int&amp;gt;(v(k++)); A(i,j) = P(temp); A(j,i) = 1/ P(temp); }else{ A(i,j) =1; } } } return(A); } // [[Rcpp::export]] double eig_max(mat A) { // 第二步：求矩阵的最大特征值 cx_vec eigval = eig_gen(A); return max(real(eigval)); } // [[Rcpp::export]] NumericVector veig_max(int n,int k =10000){ int m = 0; mat A; NumericVector res(k); for(m = 0; m&amp;lt;k;m++){ A = sample_mat(n); res(m) = eig_max(A); } return res; } 2.</description>
    </item>
    
    <item>
      <title>测试rmarkdown输出页面</title>
      <link>/post/2019-05-11-outputwidth/</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-05-11-outputwidth/</guid>
      <description>t(iris[1:30,]) #&amp;gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #&amp;gt; Sepal.Length &amp;quot;5.1&amp;quot; &amp;quot;4.9&amp;quot; &amp;quot;4.7&amp;quot; &amp;quot;4.6&amp;quot; &amp;quot;5.0&amp;quot; &amp;quot;5.4&amp;quot; &amp;quot;4.6&amp;quot; &amp;quot;5.0&amp;quot; &amp;quot;4.4&amp;quot; &amp;quot;4.9&amp;quot; &amp;quot;5.4&amp;quot; &amp;quot;4.8&amp;quot; &amp;quot;4.8&amp;quot; &amp;quot;4.3&amp;quot; &amp;quot;5.8&amp;quot; &amp;quot;5.7&amp;quot; &amp;quot;5.4&amp;quot; &amp;quot;5.1&amp;quot; &amp;quot;5.7&amp;quot; &amp;quot;5.1&amp;quot; &amp;quot;5.4&amp;quot; &amp;quot;5.1&amp;quot; &amp;quot;4.6&amp;quot; &amp;quot;5.1&amp;quot; &amp;quot;4.8&amp;quot; &amp;quot;5.0&amp;quot; &amp;quot;5.0&amp;quot; &amp;quot;5.2&amp;quot; &amp;quot;5.2&amp;quot; &amp;quot;4.7&amp;quot; #&amp;gt; Sepal.Width &amp;quot;3.5&amp;quot; &amp;quot;3.0&amp;quot; &amp;quot;3.2&amp;quot; &amp;quot;3.</description>
    </item>
    
    <item>
      <title>残缺区间群体决策模型（GDM Liu 2012)</title>
      <link>/uncertain/2019-05-05-incomplete-interval-gdm/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-05-05-incomplete-interval-gdm/</guid>
      <description>残缺区间群体决策模型（GDM） 0. 参考论文: 1. 主要思路（刘芳2012年）： 2.主要函数构建： 3.测试 3.1 测试1 3.2 测试2 4 .总结 残缺区间群体决策模型（GDM） 0. 参考论文: 徐泽水： A consistency improving method in the analytic hierarchy process 1999年
刘芳：Acceptable consistency analysis of interval reciprocal comparison matrices 2009年
刘芳： A goal programming model for incomplete interval multiplicative preference relations and its application in group decision-making 2012年
1. 主要思路（刘芳2012年）： 先把残缺区间矩阵\(U_k\)通过某种方法(LOP2)或者利用粒子群算法)进行补全成\(U_k^{’}\)， 检查补全以后的矩阵\(U_{k}^{&amp;#39;}\)是否具有一致性(\(U_{k}^{&amp;#39;}\)具有一致性 的充要条件 是 \(U_{k}^{&amp;#39;}\) 分解成单个的正互反判断矩阵B 和D，矩阵B和D的CR &amp;lt;= 0.1)，不具有则调整（按照徐泽水1999年提出的论文进行调整) 若\(U_{k}^{&amp;#39;}\)具有一致性，则进行群体决策模型构建，生成最终的区间判断矩阵U 通过最终的区间判断矩阵U生成区间权重，注意生成区间权重并没有归一化权重，根据区间权重生成可能度矩阵P. 2.主要函数构建： consistency(A): 求正互反判断矩阵的一致性指标，返回一个list</description>
    </item>
    
    <item>
      <title>求区间可能度矩阵的算法(Liu 2009)</title>
      <link>/uncertain/2019-05-04-interval-of-possibility-degree/</link>
      <pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-05-04-interval-of-possibility-degree/</guid>
      <description>求区间可能度矩阵的算法 0. 参考论文: 1. 主要思路： 2.主要函数构建： 3. 测试 3.1 例1： B 和D都满足一致性指标 3.2 例2： B 和D不满足一致性指标 4. 总结: 求区间可能度矩阵的算法 0. 参考论文: 徐泽水： A consistency improving method in the analytic hierarchy process 1999年
刘芳：Acceptable consistency analysis of interval reciprocal comparison matrices 2009年
1. 主要思路： 把区间乘性互反矩阵U拆成两个正互反判断矩阵B和D,B，D都是正的互反判断矩阵。其中B的下三角元素大于D矩阵的下三角元素，B的上三角小于D的上三角元素 ，简称B的下三角大，上三角小 一致性检验，若拆分后的B，D矩阵一致性不满足条件(即\(CR&amp;lt;= 0.1\)) ，则用徐泽水(1999年)的文章方法进行调整，直到满足一致性条件为准(\(CR &amp;lt;=0.1\)). 然后分别计算矩阵\(B，D\)的权重向量\(w(B),w(D)\) ,注意这里的权重没有归一化处理. 通过公式\(w_i = [min(w_i(B),w_i(D)),max(w_i(B),w_i(D))]\),把两个权重向量组合成一个区间向量。 通过区间向量\(w\)计算出区间向量的可能度矩阵\(P\)。 2.主要函数构建： consistency(A): 求正互反判断矩阵的一致性指标，返回一个list
em_get_w(A) : 特征值求权重 —— 没有归一化权重
gm_get_w(A)： 几何平均求权重 — — 没有归一化权重
get_w(B,D): 分别获取B，D的权重（可以指定几何平均或者特征值求权重），然后组成区间权重向量（即小的在前，大的在后），这里返回的是一个矩阵，把每一个区间数看做矩阵的一行。</description>
    </item>
    
    <item>
      <title>正互反矩阵一致性调整方法(徐泽水1999)</title>
      <link>/uncertain/2019-05-03-adjust-w-xuzeshui1999/</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-05-03-adjust-w-xuzeshui1999/</guid>
      <description>正互反矩阵一致性调整方法(徐泽水1999) 0. 参考论文： 1. 算法步骤： 2. 主要函数构建 3. 测试 3.1 矩阵1 — 论文的example1 3.2 测试矩阵2 — 论文的example2 4. 总结 正互反矩阵一致性调整方法(徐泽水1999) 0. 参考论文： 徐泽水：A consistency improving method in the analytic hierarchy process 1999年
以下是对论文的实现。
1. 算法步骤： 主要算法步骤：
假设\(A = (a_{ij})_{n \times n }\) 是一个正互反判断矩阵，迭代步骤记为\(k\)， 调整参数\(0 &amp;lt; \lambda &amp;lt;1\)
令\(A^{0} = A\)， \(CR^* = 0.1,k =0\)
计算\(A^{k} = (a_{ij}^{k})_{n\times n}\) 的最大特征值\(\lambda_{max}(A^k)\)以及对应的特征向量\(w^{k} = (w_1^k,w_2^k,\cdots,w_n^k)\)
计算一致性指标\(CI^{k} = \dfrac{\lambda_{max}(A^k) -n}{n-1}\),以及一致性比率\(CR^{k} = \dfrac{CI^k}{RI}\)，\(RI\)指标有Saaty给出。
如果\(CR^k &amp;lt; CR^*\)，则转第6步，否则转第5步</description>
    </item>
    
    <item>
      <title>环境</title>
      <link>/md/2019-05-02-environment/</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-05-02-environment/</guid>
      <description>环境 详细的解释可以查看书《高级R语言编程指南》,这里总结一份与环境有关的函数总结：(参考R语言核心技术手册第二版)
函数 描述 assign 在envir环境中将名称x赋给value对象 get 在envir环境中获得与名称x关联的对象 exists 判断在环境envir是是否定义了名称x objects 以向量的形式返回envir环境中定义的所有(对象)名称 remove 从envir环境中将参数中罗列的对象删除(列表不适合作为参数的名称，尤其当参数是向量时) search 以向量的形式列出全局环境的所有父环境，也称为搜索路径 searchpaths 以向量的形式返回全局环境的所有父环境的路径 attach 将列表、数据框或数据文件中的对象添加到当前的搜索路径中 detach 将列表、数据框或数据文件中的对象从当前的搜索路径中删除 emptyenv 空环境对象，它是所有环境的祖先，也是唯一一个没有父环境的的环境 parent.env 查看envir环境的父环境 baseenv 基础环境，它是R基础软件包的环境，它的父环境是空环境 globalenv(或.GlobalEnv) 用户的工作环境，也叫全局环境，通常情况下我们就是在这个环境中工作的，全局环境的父环境是由library() 或require()添加的最后一个添加包 environment 它是当前环境，(默认情况下，当前环境等于全局环境) new.env 手动创建一个新的环境对象 parent.frame 返回函数被调用的环境 ,即可以访问调用环境的父环境，常常作为参数使用，需要搭配其他函数eg:eval 函数调用 — 以堆栈的形式调用 调用栈的操作
函数 描述 sys.call 返回一个包含当前函数调用(包括参数)的语言对象 sys.frame 返回调用环境 sys.nframe 返回当前帧的编号(即在调用堆栈中的位置)，如果在R控制台中调用该函数，返回值为0, sys.function 返回当前计算的函数 sys.parent 返回父环境的编号 sys.calls 返回栈中所有帧的调用 sys.frames 返回栈中所有的环境 sys.parents 返回栈中每个帧的父帧 sys.on.exit 返回当前on.exit所使用的表达式 sys.status 返回一个列表 parent.frame 返回sys.frame(sys.parent(n)) ,即返回函数被调用的父环境，即允许访问调用父环境.常常作为参数使用，需要搭配其他函数eg:eval 参考 《R语言核心编程技巧第二版》</description>
    </item>
    
    <item>
      <title>非标准计算</title>
      <link>/post/2019-05-02-nonstandard-calculation/</link>
      <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-05-02-nonstandard-calculation/</guid>
      <description>非标准计算 1. 捕获表达式 1.1 quote() : 1.2 substitute 1. 3. 创建函数调用 1.4 .substitute_q() 对substituted()的补充 1.5. subs()函数 2. 对捕获表达式后的处理方式 2.1. 执行表达式 — — eval() 2.2 eval 函数的用法 2 .3 .表达式与字符串相互转变 参考 非标准计算 1. 捕获表达式 将表达式捕获转为语言对象，捕获表达式意味着防止表达式被执行，而将其本身存储为变量的形式。具有这个功能的函数有如下几个函数，注意其不同。
1.1 quote() : ​ quote()捕获到函数调用是会返回调用，而捕获到变量名时会返回一个符号，只要代码语法正确，它就会返回表示被捕获表达式本身的语言对象。即便函数不存在或者变量未定义，也可以捕获表达式本身。
rm(list = ls() ) x = quote(a+b) # 定义一个表达式调用,但是这些变量没有定义 x #&amp;gt; a + b class(x) #&amp;gt; [1] &amp;quot;call&amp;quot; typeof(x) # 变成语言对象类型， #&amp;gt; [1] &amp;quot;language&amp;quot; x = quote(rnorm) x #&amp;gt; rnorm class(x) #&amp;gt; [1] &amp;quot;name&amp;quot; typeof(x) # 变成符号对象类型， #&amp;gt; [1] &amp;quot;symbol&amp;quot; quote(xfun(a = 1:n)) # xfun都么有定义 #&amp;gt; xfun(a = 1:n) 理解：变量和符号对象的区别，以及函数和调用对象的区别。</description>
    </item>
    
    <item>
      <title>R函数参数的有关问题</title>
      <link>/post/2019-05-01-function-arguments/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-05-01-function-arguments/</guid>
      <description>R函数参数的有关问题 1. args 可以用来查看某个函数包含了哪些参数 2. 匹配参数— match.arg() 3. 以字符串作为函数名 — get函数 4. 以字符串作为函数名 — call()函数 5. 把函数参数(不带字符串参数)转变为字符串 R函数参数的有关问题 1. args 可以用来查看某个函数包含了哪些参数 args(sin) #&amp;gt; function (x) #&amp;gt; NULL args(lm) #&amp;gt; function (formula, data, subset, weights, na.action, method = &amp;quot;qr&amp;quot;, #&amp;gt; model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, #&amp;gt; contrasts = NULL, offset, ...) #&amp;gt; NULL args(paste) #&amp;gt; function (..., sep = &amp;quot; &amp;quot;, collapse = NULL, recycle0 = FALSE) #&amp;gt; NULL 2.</description>
    </item>
    
    <item>
      <title>数据框删除列的方法汇总</title>
      <link>/md/2019-05-01-remove-dataframe-columns/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-05-01-remove-dataframe-columns/</guid>
      <description>数据框删除列 iris[1:10,-5] # 1. 通过索引删除列 iris[1:10,-c(4,5)] # 删除多列 iris[1:10,-which(names(iris)%in%c(&amp;#34;Petal.Width&amp;#34;,&amp;#34;Species&amp;#34;))]# 2.根据列名进行删除 subset(iris, select = -c(Petal.Width, Species))# 3 根据列名进行删除 iris[1:10,1:4]# 筛选出需要的列 </description>
    </item>
    
    <item>
      <title>list 操作重要的函数</title>
      <link>/post/2019-04-30-listoperate/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-04-30-listoperate/</guid>
      <description>list 操作重要的函数 1.捕获省略号中的内容 2.map函数 3.reduce 函数和accumulate 函数 4. do.call函数 5. 把正常数据(数据框)转变为list 6. 更多list操作 list 操作重要的函数 ​ 我们知道R中比较复杂的数据结构为list，它可以构造出很多我们想要的数据格式，今天我们结合函数…的操作，讲解一下对一个长度不定的list如何便捷的操作。
以前提过可参考：(这里直接copy)
1.捕获省略号中的内容 ​ 先看一个例子：构造一个函数然后对所有的参数进行相加求和。
addemup &amp;lt;- function(x, ...){ args &amp;lt;- list(...)# 推荐把省略号的内容分配给list,然后在对该list进行操作 for (a in args){ x &amp;lt;- x + a } x } addemup(1,1) #&amp;gt; [1] 2 addemup(1,2,3,4,5) #&amp;gt; [1] 15 ​ 我们还可以通过..1,..2到..9等直接引用列表…中的内容。..1表示第一项，..2表示第二项，以此类推。
对list操作可以结合purrr包中的map, reduce, accumulate和基础函数do.call等 操作更方便。一个实际的例子，
DGM_U = function(...){ ####### 第一部分是对参数的检查 ##################### # 输入的参数为U_{k}，U_{k}代表一个完整的区间乘积互反判断矩阵。 n = nrow(..1) m = ncol(..1) args &amp;lt;- list(.</description>
    </item>
    
    <item>
      <title>省略号参数— 可变长参数</title>
      <link>/post/2019-04-30-ellipsisparameter/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-04-30-ellipsisparameter/</guid>
      <description>省略号参数— 可变长参数 1.捕获省略号中的内容 2. 用省略号传递给图形参数 3. 将省略号与其他参数结合 4. 也可对省略号取名称 5. 将省略号参数解压缩为本地函数变量（甚至是全局变量） 省略号参数— 可变长参数 ​ 在R中我们查看别人的函数或者内部函数，经常用到…这种参数，...也称把可变长参数，今天就来聊一聊中方法的使用。
1.捕获省略号中的内容 先看一个例子：构造一个函数然后对所有的参数进行相加求和。
addemup &amp;lt;- function(x, ...){ args &amp;lt;- list(...)# 推荐把省略号的内容分配给list,然后在对该list进行操作 for (a in args){ x &amp;lt;- x + a } x } addemup(1,1) #&amp;gt; [1] 2 addemup(1,2,3,4,5) #&amp;gt; [1] 15 我们还可以通过..1,..2到..9等直接引用列表…中的内容。..1表示第一项，..2表示第二项，以此类推。
对list操作可以结合purrr包中的map, reduce, accumulate和基础函数do.call等 操作更方便。一个实际的例子，
DGM_U = function(...){ ####### 第一部分是对参数的检查 ##################### # 输入的参数为U_{k}，U_{k}代表一个完整的区间乘积互反判断矩阵。 n = nrow(..1) m = ncol(..1) args &amp;lt;- list(...) stopifnot( length(args) &amp;gt;=2, all( map_lgl(args,is.</description>
    </item>
    
    <item>
      <title>R画带箭头的坐标轴</title>
      <link>/post/2019-04-26-rplotarrows/</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019-04-26-rplotarrows/</guid>
      <description>0.1 R 语言画带箭头的坐标轴 0.1.1 方法一 0.1.2 方法二： 0.1.3 方法三 0.2 基本函数画多折线图 0.1 R 语言画带箭头的坐标轴 本质的方法：就是去掉原有的坐标轴，然后通过R的低等函数一步一步的画出坐标轴以及需要的曲线，以下是google到的几种方法：
0.1.1 方法一 ################## 画带箭头的坐标轴 ## estimate curve x &amp;lt;- seq(-1,1.5,0.1); y &amp;lt;- c(1.3,1.32,1.33,1.32,1.25,1.1,0.7,0.5,0.4,0.38,0.4,0.41,0.42,0.43,0.44,0.4,0.3,0.1,0,-0.05,-0.1,-0.15,-0.2,-0.24,-0.28,-0.3); f &amp;lt;- splinefun(x,y); ## calculate precise points along estimated curve x &amp;lt;- seq(-1,1.5,0.01); y &amp;lt;- f(x); ## precompute limits xlim &amp;lt;- c(min(x),max(x)); ylim &amp;lt;- c(min(y)-0.4,max(y)+0.2); ## set global plot params par(xaxs=&amp;#39;i&amp;#39;,yaxs=&amp;#39;i&amp;#39;,mar=c(1,1,3,3)+0.1); ## &amp;quot;internal&amp;quot; axis spacing, meaning no extended range, and slightly adjust margins ## draw plot plot(NA,xlim=xlim,ylim=ylim,axes=F,ann=F); ## set plot bounds, no default ornaments arrows(c(0,xlim[1]),c(ylim[1],0),c(0,xlim[2]),c(ylim[2],0),0.</description>
    </item>
    
    <item>
      <title>学术论文写作工具</title>
      <link>/md/2019-04-26-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-04-26-%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/</guid>
      <description>1. 基础配置 1、必备： CTEX套装 或者 TexLive (推荐),安装Texlive时候，推荐搭配Texstudio
2、有没有发现写公式很麻烦：mathpix 工具可以直接截图，把截图的公式转变为Latex 代码，太复杂的可能识别不了，但是已经很好了
3、AxMath 可以像mathtpye那样输入公式，更重要的一点是可以直接转变为latex代码，
4、LaTeX代码转为Word公式:
​	可以参考这篇文章： http://www.latexstudio.net/archives/4650.html
​	如果在word里面直接输入LaTex代码转word公式,eg: 输入$x^2 + y^2$ ,然后选中其按 alt + \ 即可转换，不过有点慢，耐心等待
5、 Typora 工具，写markdown的，可以写md文件，然后转出latex文件，不过转出的导言区一般是有问题的，我们直接要正文部分，向导言区的头文件之类，要根据文件适当自己添加，这是由于公式的问题，公式之间不能用空行。
\documentclass{article} \usepackage{ctex} % 中文包,如果含有公式也适用 \usepackage[colorlinks,linkcolor=red]{hyperref} % 超链接 \begin{document} 。。。正文。。。。。x \end{document} 6、推荐写公式时，不用空白行。
2. 表格to latex 方法一：http://www.tablesgenerator.com/latex_tables :这个网站不错，就是打开有点慢（推荐）。 以及这个网站https://tableconvert.com/ 方法二： 可以安装Excel2latex 插件，自己百度 方法三：在rstudio中使用stargazer包 (三线头表格,头是双线） 方法四： 在rstudio中使用xtable包( 三线头表格，头是单线) ##### 方法三：##### library(stargazer) library(xlsx) # 推荐使用这个包，因为不会发生小数点精度的问题，但是列名可能会发生改变 # 原本的列名是 3，4，....,9 读入后变成了X3,X4,....,X9. data = read.xlsx(file =&amp;#34;工作簿1.xlsx&amp;#34;,sheetIndex = 1, header = T,colClasses = &amp;#34;character&amp;#34;) data stargazer(data,summary = F,rownames = F) ##### 方法四： ##### xtable::xtable(head(iris),digits=3,caption=&amp;#34;Head of Iris Data&amp;#34;) # 其中函数中的digits=3控制输出精度，caption就是表格的标题。 注意看下图： 把代码粘贴到latex编译器中，上图为方法三画的(一般学术论文，表的标题在上方，图的标题在下方) ，下图为方法四画的。</description>
    </item>
    
    <item>
      <title>1.5.2离差最大化的多属性决策方法</title>
      <link>/uncertain/2019-02-26-1-5%E5%9F%BA%E4%BA%8E%E7%A6%BB%E5%B7%AE%E6%9C%80%E5%A4%A7%E5%8C%96/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-26-1-5%E5%9F%BA%E4%BA%8E%E7%A6%BB%E5%B7%AE%E6%9C%80%E5%A4%A7%E5%8C%96/</guid>
      <description>徐泽水《不确定多属性决策方法与应用》24页 –1.52 实例分析 徐泽水《不确定多属性决策方法与应用》24页 –1.52 实例分析 ##### 1.5.2离差最大化的多属性决策方法---徐泽水《不确定多属性决策方法与应用》24页 --1.52 实例分析 library(data.table) library(dplyr) A= c(12,11.5,780,175,22,2.43, 12,14.6,898,165,33.5,2.83, 10.3,13.5,741,181,22.7,3, 12,15.24,1038,204,47.3,4, 11.4,12.19,833.4,180,19,5.9, 9,12.8,667,170,19.8,3.8, 12.2,13.37,991,170,59,3.3, 12,14.3,1048,230,37.2,1.9, 9,6.25,287,105,5,3.6, 10.33,15,927,167,52.6,3.14) A= matrix(A,nrow = 10,ncol = 6,byrow = T) %&amp;gt;% data.table() A # 原始决策矩阵 ， 也称决策矩阵 #&amp;gt; V1 V2 V3 V4 V5 V6 #&amp;gt; 1: 12.00 11.50 780.0 175 22.0 2.43 #&amp;gt; 2: 12.00 14.60 898.0 165 33.5 2.83 #&amp;gt; 3: 10.30 13.50 741.0 181 22.7 3.00 #&amp;gt; 4: 12.</description>
    </item>
    
    <item>
      <title>1.6 基于信息熵的多属性决策方法</title>
      <link>/uncertain/2019-02-26-1-6%E5%9F%BA%E4%BA%8E%E4%BF%A1%E6%81%AF%E7%86%B5%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-26-1-6%E5%9F%BA%E4%BA%8E%E4%BF%A1%E6%81%AF%E7%86%B5%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</guid>
      <description>徐泽水《不确定多属性决策方法与应用》26页 徐泽水《不确定多属性决策方法与应用》26页 ## 1.6 基于信息熵的多属性决策方法---徐泽水《不确定多属性决策方法与应用》26页 --1.62 实例分析 library(data.table) library(dplyr) A = c(2,1.5,2,5.5,5,9, 2.5,2.7,1.8,6.5,3,5, 1.8,2,2.1,4.5,7,7, 2.2,1.8,2,5,5,5) A= matrix(A,nrow = 4,ncol = 6,byrow = T) %&amp;gt;% data.table() A # 原始决策矩阵 #&amp;gt; V1 V2 V3 V4 V5 V6 #&amp;gt; 1: 2.0 1.5 2.0 5.5 5 9 #&amp;gt; 2: 2.5 2.7 1.8 6.5 3 5 #&amp;gt; 3: 1.8 2.0 2.1 4.5 7 7 #&amp;gt; 4: 2.2 1.8 2.0 5.0 5 5 ####################################################### ##### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵 ########################################################## ### norm_matrix()函数，根据书中收益型属性（按公式1.</description>
    </item>
    
    <item>
      <title>1.7方案有偏好信息的多属性决策方法</title>
      <link>/uncertain/2019-02-26-1-7%E6%96%B9%E6%A1%88%E6%9C%89%E5%81%8F%E5%A5%BD%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-26-1-7%E6%96%B9%E6%A1%88%E6%9C%89%E5%81%8F%E5%A5%BD%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</guid>
      <description>徐泽水《不确定多属性决策方法与应用》27–37页 1.对方案的偏好信息为互反判断矩阵的情形 2.对方案的偏好信息为模糊互补判断矩阵的情形 3.对方案的偏好信息为效用值的情形 徐泽水《不确定多属性决策方法与应用》27–37页 1.对方案的偏好信息为互反判断矩阵的情形 ## 1 对方案的偏好信息为互反判断矩阵的情形 library(data.table) library(dplyr) A = c(3.0,100,10,7, 2.5,80,8,5, 1.8,50,20,11, 2.2,70,12,9) A= matrix(A,nrow = 4,ncol = 4,byrow = T) %&amp;gt;% data.table() A # 原始决策矩阵 #&amp;gt; V1 V2 V3 V4 #&amp;gt; 1: 3.0 100 10 7 #&amp;gt; 2: 2.5 80 8 5 #&amp;gt; 3: 1.8 50 20 11 #&amp;gt; 4: 2.2 70 12 9 ####################################################### ##### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵 ########################################################## ### norm_matrix()函数，根据书中收益型属性（按公式1.2）与成本型属性(按公式1.4)分别进行归一化 # 参数A表示决策矩阵,shouyi参数代表收益型属性，输入收益型属性在决策矩阵中第几列，若有多列，用数值型向量即可， # chengben参数代表成本型属性，与收益型属性类型。 # 该参数可任选其一输入，也可同时指定。 norm_matrix = function(A,shouyi=NULL,chengben=NULL){ if(is.</description>
    </item>
    
    <item>
      <title>2.1 模糊互补判断矩阵的排序方法</title>
      <link>/uncertain/2019-02-26-2-1%E6%A8%A1%E7%B3%8A%E4%BA%92%E8%A1%A5%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-26-2-1%E6%A8%A1%E7%B3%8A%E4%BA%92%E8%A1%A5%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/</guid>
      <description>徐泽水《不确定多属性决策方法与应用》59页 徐泽水《不确定多属性决策方法与应用》59页 ### 2.1 模糊互补判断矩阵的排序方法---徐泽水《不确定多属性决策方法与应用》59页 --2.1.6 实例分析 # 以及55页 例 2.1 B = c(0.5,0.7,0.6,0.8, 0.3,0.5,0.4,0.6, 0.4,0.6,0.5,0.7, 0.2,0.4,0.3,0.5) B = matrix(B, nrow = 4,ncol = 4,byrow = T) ######## MTM 排序法---模糊互补判断矩阵的中转法 # MTM 函数直接输入模糊互补判断矩阵B，直接即可求出对应案例（即行，决策矩阵行代表案例，列代表属性）的权重向量w. MTM = function(B){ w = 0 n = nrow(B) m = ncol(B) stopifnot(n==m) for(i in 1:n){ w[i] =( sum(B[i,]) + n/2 -1) /(n*(n-1)) } return(w) } MTM(B) #&amp;gt; [1] 0.3000000 0.2333333 0.2666667 0.2000000 ########## LVM 排序---- 模糊互补判断矩阵排序的最小方差法 # LVM函数直接输入模糊互补判断矩阵B，直接即可求出对应案例（即行，决策矩阵行代表案例，列代表属性）的权重向量w.</description>
    </item>
    
    <item>
      <title>3.1 基于理想点的多属性决策方法</title>
      <link>/uncertain/2019-02-26-3-1%E5%9F%BA%E4%BA%8E%E7%90%86%E6%83%B3%E7%82%B9%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-26-3-1%E5%9F%BA%E4%BA%8E%E7%90%86%E6%83%B3%E7%82%B9%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</guid>
      <description>徐泽水《不确定多属性决策方法与应用》78页 徐泽水《不确定多属性决策方法与应用》78页 ## 3.1 基于理想点的多属性决策方法---徐泽水《不确定多属性决策方法与应用》78页 --3.1.2 实例分析 library(data.table) library(dplyr) A = c(0.37,1800,2,19,90, 0.58,2800,5,28,105, 0.52,3500,5,32,130, 0.43,1900,3,27,98) A= matrix(A,nrow = 4,ncol = 5,byrow = T) %&amp;gt;% data.table() A # 原始决策矩阵 #&amp;gt; V1 V2 V3 V4 V5 #&amp;gt; 1: 0.37 1800 2 19 90 #&amp;gt; 2: 0.58 2800 5 28 105 #&amp;gt; 3: 0.52 3500 5 32 130 #&amp;gt; 4: 0.43 1900 3 27 98 ####################################################### ############################## ################## 正理想点偏差 ----- 且 决策者不能提供任何权重信息 ############### ####################################################### ############################## #### 第一步把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵 ### norm_matrix()函数，根据书中收益型属性（按公式1.</description>
    </item>
    
    <item>
      <title>3.2 基于方案满意度的多属性决策方法</title>
      <link>/uncertain/2019-02-26-3-2%E5%9F%BA%E4%BA%8E%E6%96%B9%E6%A1%88%E6%BB%A1%E6%84%8F%E5%BA%A6%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-26-3-2%E5%9F%BA%E4%BA%8E%E6%96%B9%E6%A1%88%E6%BB%A1%E6%84%8F%E5%BA%A6%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</guid>
      <description>徐泽水《不确定多属性决策方法与应用》81页 第一步: 把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵 第二步 ： 求出综合属性正理想值z_max,以及综合属性负理想值z_min 第三步： 求出各方按的满意度，PW 矩阵的每一行为对应方案的满意度矩阵 徐泽水《不确定多属性决策方法与应用》81页 ## 3.2 基于方案满意度的多属性决策方法---徐泽水《不确定多属性决策方法与应用》81页 --3.2.2 实例分析 library(data.table) library(dplyr) A = c(47177, 16.61, 8.89, 31.05, 15.77, 43323, 9.08, 3.65, 29.80, 8.44, 59023, 13.84, 6.06, 26.55, 12.87, 46821, 10.59, 3.51, 22.46, 7.41, 41646, 13.24, 4.64, 24.33, 9.33, 26446, 10.16, 2.38, 26.80, 9.85, 38381, 11.97, 4.79, 26.45, 10.64, 57808, 10.29, 4.54, 23.00, 9.23, 28869, 7.68, 2.12, 31.08, 9.05, 38812, 8.92, 3.38, 25.68, 8.</description>
    </item>
    
    <item>
      <title>3.3 基于方差最大化模型的多属性决策方法</title>
      <link>/uncertain/2019-02-26-3-3%E5%9F%BA%E4%BA%8E%E6%96%B9%E5%B7%AE%E6%9C%80%E5%A4%A7%E5%8C%96%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-26-3-3%E5%9F%BA%E4%BA%8E%E6%96%B9%E5%B7%AE%E6%9C%80%E5%A4%A7%E5%8C%96%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</guid>
      <description>徐泽水《不确定多属性决策方法与应用》84页 徐泽水《不确定多属性决策方法与应用》84页 ## 3.3 基于方差最大化模型的多属性决策方法---徐泽水《不确定多属性决策方法与应用》84页 --3.3.2 实例分析 library(data.table) library(dplyr) A = c(18400,3,100,80,300,60,40,1.2, 19600,4,120,100,400,80,40,1.3, 29360,6,540,120,150,100,50,1.5) A= matrix(A,nrow = 3,ncol = 8,byrow = T) %&amp;gt;% data.table() A # 原始决策矩阵 #&amp;gt; V1 V2 V3 V4 V5 V6 V7 V8 #&amp;gt; 1: 18400 3 100 80 300 60 40 1.2 #&amp;gt; 2: 19600 4 120 100 400 80 40 1.3 #&amp;gt; 3: 29360 6 540 120 150 100 50 1.5 #### 第一步: 把原始决策矩阵A 利用适当的方法进行规范化为R，R为归一化后的矩阵 ### norm_matrix()函数，根据书中收益型属性（按公式1.</description>
    </item>
    
    <item>
      <title>4.1 基于可能度的多属性决策方法</title>
      <link>/uncertain/2019-02-26-4-1%E5%9F%BA%E4%BA%8E%E5%8F%AF%E8%83%BD%E5%BA%A6%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-26-4-1%E5%9F%BA%E4%BA%8E%E5%8F%AF%E8%83%BD%E5%BA%A6%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</guid>
      <description>第四章–属性权重为实数且属性值为区间数的多属性决策方法及应用 徐泽水《不确定多属性决策方法与应用》109页 第四章–属性权重为实数且属性值为区间数的多属性决策方法及应用 徐泽水《不确定多属性决策方法与应用》109页 ##### 第四章--属性权重为实数且属性值为区间数的多属性决策方法及应用 ## 4.1 基于可能度的多属性决策方法---徐泽水《不确定多属性决策方法与应用》109页 ## 4.1.4 实例分析 ##### 第一步： 求出规范化矩阵 A = c(0.214,0.220,0.166,0.178,0.184,0.190, 0.206,0.225,0.220,0.229,0.182,0.191, 0.195,0.204,0.192,0.198,0.220,0.231, 0.181,0.190,0.195,0.205,0.185,0.195, 0.175,0.184,0.193,0.201,0.201,0.211) R = matrix(A,nrow = 5,byrow = T) # R为规范化后的决策矩阵 R # 矩阵R的奇数列代表属性的下界 ，偶数列代表属性的上界 #&amp;gt; [,1] [,2] [,3] [,4] [,5] [,6] #&amp;gt; [1,] 0.214 0.220 0.166 0.178 0.184 0.190 #&amp;gt; [2,] 0.206 0.225 0.220 0.229 0.182 0.191 #&amp;gt; [3,] 0.195 0.204 0.192 0.198 0.220 0.231 #&amp;gt; [4,] 0.181 0.</description>
    </item>
    
    <item>
      <title>4.2基于投影的多属性决策方法(含4.3区间归一化)</title>
      <link>/uncertain/2019-02-26-4-2%E5%9F%BA%E4%BA%8E%E6%8A%95%E5%BD%B1%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-26-4-2%E5%9F%BA%E4%BA%8E%E6%8A%95%E5%BD%B1%E7%9A%84%E5%A4%9A%E5%B1%9E%E6%80%A7%E5%86%B3%E7%AD%96%E6%96%B9%E6%B3%95/</guid>
      <description>4.3 区间归一化 #徐泽水《不确定多属性决策方法与应用》112页 ## 第四章–属性权重为实数且属性值为区间数的多属性决策方法及应用 ### 4.2 基于投影的多属性决策方法
##### 第四章--属性权重为实数且属性值为区间数的多属性决策方法及应用 ## 4.2 基于投影的多属性决策方法---徐泽水《不确定多属性决策方法与应用》112页 ## 4.2.2 实例分析 ##### 第一步： 求出规范化矩阵 A = c(58.9,59,200,250,1.9,2.1,0.990,0.991,0.907,0.909, 58.5,58.7,340,350,3.4,3.5,0.990,0.992,0.910,0.912, 58.0,58.5,290,310,2.0,2.2,0.992,0.993,0.914,0.917) A = matrix(A,nrow = 3,byrow = T) # A为决策矩阵 A # 矩阵A的奇数列代表属性的下界 ，偶数列代表属性的上界 #&amp;gt; [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] #&amp;gt; [1,] 58.9 59.0 200 250 1.9 2.1 0.990 0.991 0.907 0.909 #&amp;gt; [2,] 58.5 58.7 340 350 3.4 3.5 0.990 0.</description>
    </item>
    
    <item>
      <title>不确定多属性决策方法徐泽水pdf</title>
      <link>/uncertain/2019-02-25%E4%B8%8D%E7%A1%AE%E5%AE%9A%E5%A4%9A%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E5%BE%90%E6%B3%BD%E6%B0%B4pdf/</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/uncertain/2019-02-25%E4%B8%8D%E7%A1%AE%E5%AE%9A%E5%A4%9A%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E5%BE%90%E6%B3%BD%E6%B0%B4pdf/</guid>
      <description>https://cdn.jsdelivr.net/gh/zscmmm/imgs2208save@master/img/xuzeshui不确定多属性决策方法及应用_徐泽水.pdf</description>
    </item>
    
    <item>
      <title>运筹学与最优化--在R软件中的实现</title>
      <link>/md/2019-02-18-%E8%BF%90%E7%AD%B9%E5%AD%A6%E4%B8%8E%E6%9C%80%E4%BC%98%E5%8C%96r/</link>
      <pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/md/2019-02-18-%E8%BF%90%E7%AD%B9%E5%AD%A6%E4%B8%8E%E6%9C%80%E4%BC%98%E5%8C%96r/</guid>
      <description>转载过来的，
参考链接1:
参考链接2:
备注链接:</description>
    </item>
    
    <item>
      <title>运筹学最短路问题</title>
      <link>/md/2018-11-22-%E8%BF%90%E7%AD%B9%E5%AD%A6%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 22 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-22-%E8%BF%90%E7%AD%B9%E5%AD%A6%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98/</guid>
      <description>最短路算法参考(自制ppt)pdf:</description>
    </item>
    
    <item>
      <title>R语言输出latex或html</title>
      <link>/post/2018-11-21-r%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BAlatex%E6%88%96html%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-11-21-r%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BAlatex%E6%88%96html%E6%A0%BC%E5%BC%8F/</guid>
      <description>简介knitr常用参数 xtable包 输出为纯HTML格式或者LaTeX格式 若想在rmarkdown中输出时能正常显示上面的格式怎么办了？ kableExtra包 基于HTML的table 设置主题 表格样式 参考： 有一些时候，我们想把R对象输出为LaTeX格式或者HTML格式，怎么办呢？
简介knitr常用参数 xtable包 输出为纯HTML格式或者LaTeX格式 tt &amp;lt;- head(iris) # 普通的输出 library(xtable) print(xtable(tt),type=&amp;quot;html&amp;quot;) # 输出为纯HTML格式 ## &amp;lt;!-- html table generated in R 4.0.2 by xtable 1.8-4 package --&amp;gt; ## &amp;lt;!-- Mon Sep 14 21:28:39 2020 --&amp;gt; ## &amp;lt;table border=1&amp;gt; ## &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt; &amp;lt;/th&amp;gt; &amp;lt;th&amp;gt; Sepal.Length &amp;lt;/th&amp;gt; &amp;lt;th&amp;gt; Sepal.Width &amp;lt;/th&amp;gt; &amp;lt;th&amp;gt; Petal.Length &amp;lt;/th&amp;gt; &amp;lt;th&amp;gt; Petal.Width &amp;lt;/th&amp;gt; &amp;lt;th&amp;gt; Species &amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; ## &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;quot;right&amp;quot;&amp;gt; 1 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;quot;right&amp;quot;&amp;gt; 5.</description>
    </item>
    
    <item>
      <title>用c语言设置定时关机</title>
      <link>/md/2018-11-20-c%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-20-c%E8%AF%AD%E8%A8%80/</guid>
      <description>C代码 创建定时任务 发现代码，win有自动防范木马的可能，于是要手动去在定时任务勾选某些指标，所以不可行。
# include&amp;lt;stdio.h&amp;gt; # include &amp;lt;windows.h&amp;gt; int main() { //如果存在任务名为myTaskName2 则强制删除，若没有则报错，但不终止该程序的运行 system(&amp;#34;schtasks /delete /tn myTaskName2 /f&amp;#34;); // 创建一个任务名为myTaskName2的任务,/tr 后面是 要执行的命令， 双引号要转义，/st 后面接的是触发时间 system(&amp;#34;schtasks /create /tn myTaskName2 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 22:35:00&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName4 /f&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName4 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 22:42:00&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName3 /f&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName3 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 22:52:00&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName5 /f&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName6 /f&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName7 /f&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName5 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:00:00&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName6 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:15:00&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName7 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:27:00&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName8 /f&amp;#34;); system(&amp;#34;schtasks /delete /tn myTaskName9 /f&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName8 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:43:00&amp;#34;); system(&amp;#34;schtasks /create /tn myTaskName9 /f /tr \&amp;#34;shutdown -s -f -t 10\&amp;#34; /sc once /st 23:58:00&amp;#34;); return 0; } 编译运行后 编译运行后，找到对应得exe文件 ,把其放在开始启动目录中即可（C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp）</description>
    </item>
    
    <item>
      <title>运筹学与最优化matlab</title>
      <link>/md/2018-11-19-%E8%BF%90%E7%AD%B9%E5%AD%A6%E4%B8%8E%E6%9C%80%E4%BC%98%E5%8C%96matlab/</link>
      <pubDate>Sun, 18 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-19-%E8%BF%90%E7%AD%B9%E5%AD%A6%E4%B8%8E%E6%9C%80%E4%BC%98%E5%8C%96matlab/</guid>
      <description>运筹学与matlab</description>
    </item>
    
    <item>
      <title>线性规划的一般模型(草稿)</title>
      <link>/md/2018-11-17-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E8%88%AC%E6%A8%A1%E5%9E%8Btest/</link>
      <pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-17-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%80%E8%88%AC%E6%A8%A1%E5%9E%8Btest/</guid>
      <description>线性规划的一般模型 :
$$ \min \quad z = c_1x_1+c_2x_2+ \cdots + c_nx_n \ s.t.\left{ \begin{aligned}
a_{11}x_1+a_{12}x_2+ \cdots + a_{1n}x_n \leq b_1 \ a_{21}x_1+a_{22}x_2+ \cdots + a_{2n}x_n \leq b_2 \
\quad \cdots \qquad \cdots \qquad \cdots \ a_{m1}x_1+a_{m2}x_2+ \cdots + a_{mn}x_n \leq b_m \ x_1,x_2,x_3,\cdots,x_n \geq 0 \end{aligned} \right. $$</description>
    </item>
    
    <item>
      <title>重装系统后一些有用的激活工具</title>
      <link>/md/2018-11-17-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-17-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</guid>
      <description>包含win10 和office2019 激活工具 链接：https://pan.baidu.com/s/1eOQUPdlrvViL2XSucEdkmQ 提取码：08be 复制这段内容后打开百度网盘手机App，操作更方便哦</description>
    </item>
    
    <item>
      <title>R金融分析以及VaR</title>
      <link>/post/2018-11-14-r%E9%87%91%E8%9E%8D%E5%88%86%E6%9E%90%E4%B8%8Evar/</link>
      <pubDate>Wed, 14 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-11-14-r%E9%87%91%E8%9E%8D%E5%88%86%E6%9E%90%E4%B8%8Evar/</guid>
      <description>1 第一题 1.1 加载工具包 1.2 输入要研究的股票数据代码 1.2.1 下载数据并保存到本地 1.2.2 读取本地股票数据 1.2.3 删除该文件 1.3 计算日、月、年、收益率（按收盘价） 并保存数据 1.4 计算 日收益率的均值 和波动率 1.5 计算移动平均值(5,10,20,60期移动平均值) 并保存数据 1.6 画出收盘价与5 期 30 期移动平均线 1.7 寻找金叉死叉，即买卖点 1.7.1 保存买卖点 1.7.2 在图上画出买卖点，并表示标签，买入(B),卖出(S), 1.8 画出所用的均线5,10,30,60 图 以及 收盘价 以及 2均线形成（5,30）的金叉死叉 2 第二题 –VaR 2.1 输入要研究的股票数据代码 2.1.1 下载数据并保存到本地 2.1.2 读入数据 2.1.3 删除该文件 2.2 计算VaR–历史模拟法 2.3 计算VaR–韦伯法 这是一份很久以前一份作业报告.
1 第一题 1.1 加载工具包 # 加载工具包 library(plyr) library(quantmod) library(TTR) library(ggplot2) library(scales) library(stringr) library(dplyr) library(lubridate) library(dygraphs) library(RColorBrewer) library(ggfortify) library(dplyr) 1.</description>
    </item>
    
    <item>
      <title>R语言发邮件--mailR包</title>
      <link>/md/2018-11-13-%E5%8F%91%E9%82%AE%E4%BB%B6mailr%E5%8C%85/</link>
      <pubDate>Tue, 13 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-13-%E5%8F%91%E9%82%AE%E4%BB%B6mailr%E5%8C%85/</guid>
      <description>亲测试邮箱为163邮箱 和QQ邮箱
mailR 包参数 mailR 包中只有一个接口函数&amp;mdash;send.mail ,该包依恋java环境，请首先配置该环境，下面是该函数的一些基本参数：
send.mail(from, to, subject = &amp;#34;&amp;#34;, body = &amp;#34;&amp;#34;, encoding = &amp;#34;iso-8859-1&amp;#34;, html = FALSE, inline = FALSE, smtp = list(), authenticate = FALSE, send = TRUE, attach.files = NULL, debug = FALSE, ...) 参数 说明 from 发件人邮箱 to 收件人邮箱 subject 邮件标题 body 邮件的内容(正文),内容可以是文本也可以是html网页格式 html 一个bool值，是否应该讲邮箱正文解析为HTML inline 一个bool值，HTML文件中的图像是否应该被嵌入 smtp 重要的参数，设置服务器参数用的 authenticate 是否应该使用smtp中的参数 attach.files 指定相应的附件，若是多个则用字符向量表示 file.names （省略参数），对相应的附件进行重命名 debug 你是否要查看详细的调试信息 163 邮箱: 如果发送频率过快，容易被封号，暂时发布出去了，只有等解封以后再发,
注意： 在测试的时候，尽量写的和平时邮件一样的格式，不然会被认为是垃圾邮件
library(mailR) sender &amp;lt;- &amp;#34;********@163.</description>
    </item>
    
    <item>
      <title>谈谈字符编码问题</title>
      <link>/md/2018-11-06-%E8%B0%88%E8%B0%88%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 06 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-11-06-%E8%B0%88%E8%B0%88%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</guid>
      <description>最近在实验室编写文件，遇到一件奇怪的事情，在自己的笔记本上能正常编码，却在学校的电脑上编码总是乱码，于是经历种种磨难，算是弄明白了一点点，下面简单介绍一下字符编码的知识（由于编码种类繁多，我只简单的提一下，其余自己百度，文末有相关链接）
常见的字符集： ​	百度百科定义： 字符(Character)是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。字符集(Character set)是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。中文文字数目大，而且还分为简体中文和繁体中文两种不同书写规则的文字，而计算机最初是按英语单字节字符设计的，因此，对中文字符进行编码，是中文信息交流的技术基础。
​	下面介绍几个常见的字符集：ASCII字符集、GB2312、 GBK、utf-8、utf-16、utf-32
​	所谓字符集就是按一定的规则去解释或者翻译0 1 代码的，有点像翻译表或者对照表。
ASCII 以及EASCII ​	首先，我们要明白计算机内部所有东西都是以1和0来表示的，刚开始我们用8位0 1代码进行表示，一共有2^8= 256种状态，由于当时计算机很昂贵并且很大，美国人只有用了127个字符就表示了英语中所有的字符，这就是ASSIC码，从此ASSIC码诞生了，
并用后面的128~256号状态来表示西欧其他国家的字符，于是把0~256号状态的所有字符统称为扩展的ASCCI字符（即EASCII），即最高位为0 代表0~127号字符，最高位为1 是后面扩展的字符集,记住，此时计算机始终按照8位二进制进行编码.
GB2312 、GBK 、GB 18030 ​	等到了中国，发现这些0~256号状态都被别人使用了，而且中国的汉字太多，于是中国人准备用两个字节来表示一个汉字，并应该兼容最初的0~127号字符集，于是中国人这样设计，当最高位为0时，计算机就按ASSCI码(1位)进行编码，当发现最高位是1时，就按两个字节进行编码，eg: 1001000&#39;10001011 这两个字节都对应两个十进制数分别是72和11 ，于是就想设计一个二维矩阵建立与汉字的对应关系，按照这个二维矩阵的行和列一样进行查找对比，就可以确定一个汉字了，并且保留了0~127号码的对应规则（这就是我们经常发现为什么英文不乱码而中文乱码的原因）.
​	这个二维矩阵对应的字符集，就成为GB2312字符集,这样和后面的EASCCI就冲突了，然而日本、韩国等世界上几乎每个国家都有自己的字符集，于是后面的第128~256号字符集经常发生冲突（即乱码，计算机不知道应该按照GB2312、EASSIC、日文的字符集、等进行编码，所有就会出现乱码 ）。
​	这里补充说明一点，GB2312字符集表示的汉字也比较少，于是在GB2312的基础上扩展产生GBK编码以及GB 18030 等汉字字符集)
ANSI ​	严格说ANSI并不是一个字符集。前面我们讲到每个国家都有自己的编码规则，于是Windows公司设计了ANSI规则，ANSI根据电脑操作系统的设置，自动关联对应的编码，eg： 在美国就按ASCII码进行编码，并自动设置为默认编码,同理在中国，就按GBK进行编码，而在日本，就按日本对应的字符集进行编码&amp;hellip;&amp;hellip;
​	所以ANSI简单来说是一个自动判别系统,但这样在不同字符进行切换时，就会出现乱码的问题。于是迫切希望有同一的编码规则，于是Unicode 编码孕育而生。
Unicode 、utf-8、utf-16、utf-32 ​	由于世界上存在多种编码，当不同国家的人在进行发送文件时，会出现乱码（因为解读的规则不一样，同一段0 1 代码，中国按照GBK去解读，而西欧安装EASSCI字符集去解读，这样必然计算机弄不清楚，必会出现乱码）,于是有一个社区就说要不我们把世界上的所有文字都进行统一编码吧！这样就不会产生乱码了，于是产生了Unicode编码，当然Unicode是一个很大的集合，大概用了4个字节（即32位 0 1代码去表示）,这样美国人或者西欧人不干了，因为原本我存储一个英文单词words只需要5个字节，现在用Unicode就变成了20个字节，这样硬盘的空间严重浪费，于是产生出来utf-8、utf-16、utf-32字符集，这里重点解释一下utf-8字符集，这个是可变长编码，计算机可以根据前面的一个1个字节的编码规则进行自动判断，该是用一个字节去解读还是用2个、3个字节去解读(这里这个规则有点复杂，反正计算机能从第一个字节中解读出来，到底应该用几个字节取解读)。
utf-8 : 使用1~4个字节存储一个Unicode字符。 utf-16 : 使用2或4个字节存储 utf-32 : 使用4个字节存储 乱码产生的原因 ​	假设在一个文本编辑器中写入hollo world 你好世界 ，编码方式为utf-8，
​	当按下ctrl + s时，文本编辑器将会按照unicode字符集中查找每个字符对应的码，再按照utf-8的方式，将hollo world存为单字节，而将你好世界存成2~4个字节，此过程称为 编码。</description>
    </item>
    
    <item>
      <title>glmnet包解读1</title>
      <link>/post/2018-09-13-glmnet1/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-09-13-glmnet1/</guid>
      <description>1 介绍 2 快速开始 3 线性回归 3.1 高斯簇 3.2 多响应高斯簇 4 逻辑回归 4.1 二项分布逻辑回归 4.2 多分类逻辑回归 5 泊松回归 5.1 加载数据集 5.2 拟合模型 5.3 查看拟合效果 5.4 预测 6 Cox模型 6.1 载入数据集 6.2 拟合模型 6.3 查看拟合效果 6.4 交叉验证 7 稀疏矩阵 1 介绍 glmnet 包解决了一下问题（目标函数） \[ \min_{\beta_0,\beta} \frac{1}{N} \sum_{i=1}^{N} w_i l(y_i,\beta_0+\beta^T x_i) + \lambda\left[(1-\alpha)||\beta||_2^2/2 + \alpha ||\beta||_1\right], \] #### 1.1 glmnet包安装
install.packages(&amp;quot;glmnet&amp;quot;, repos = &amp;quot;http://cran.us.r-project.org&amp;quot;) 2 快速开始 这节介绍glmnet包中的主要函数以及它们的一般用法，对常用函数的输入参数以及输出结果做简要的说明。
2.1 加载glmnet包 library(glmnet)# 加载glmnet包 以线性回归为例，来说明glmnet包的用法。</description>
    </item>
    
    <item>
      <title>独热编码--哑变量</title>
      <link>/post/2018-08-31-%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81--%E5%93%91%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 31 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-08-31-%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81--%E5%93%91%E5%8F%98%E9%87%8F/</guid>
      <description>独热编码–哑变量 独热编码1 独热编码2 独热编码3 独热编码4 独热编码5 独热编码6 独热编码7 独热编码8 独热编码 转变为原始变量 （即逆运算） 独热编码–哑变量 独热编码： n种状态 转变为n列
哑变量： n种状态转变为n-1列（目的：为了防止共线性的问题）
testFrame &amp;lt;- data.frame(First=sample(1:10, 20, replace=TRUE), Second=sample(1:20, 20, replace=TRUE), Third=sample(1:10, 20, replace=TRUE), Fourth=factor(rep(c(&amp;quot;=A&amp;quot;, &amp;quot;=B&amp;quot;, &amp;quot;=C&amp;quot;, &amp;quot;=D&amp;quot;),5)), Fifth=ordered(rep(c(&amp;quot;=E&amp;quot;, &amp;quot;=F&amp;quot;, &amp;quot;=G&amp;quot;,&amp;quot;=H&amp;quot;, &amp;quot;=I&amp;quot;), 4)), Sixth=rep(c(&amp;quot;=a&amp;quot;, &amp;quot;=b&amp;quot;), 10), Seventh=factor(c(rep(c(&amp;quot;=J&amp;quot;,&amp;quot;=K&amp;quot;,&amp;quot;=L&amp;quot;),6),&amp;quot;=J&amp;quot;,&amp;quot;=K&amp;quot;)) , stringsAsFactors=F) head(testFrame) #&amp;gt; First Second Third Fourth Fifth Sixth Seventh #&amp;gt; 1 8 7 8 =A =E =a =J #&amp;gt; 2 9 2 5 =B =F =b =K #&amp;gt; 3 7 20 10 =C =G =a =L #&amp;gt; 4 4 9 3 =D =H =b =J #&amp;gt; 5 1 6 2 =A =I =a =K #&amp;gt; 6 1 13 1 =B =E =b =L str(testFrame) #&amp;gt; &amp;#39;data.</description>
    </item>
    
    <item>
      <title>ggplot2一页多图(图独立)</title>
      <link>/post/2018-07-15-ggplot2%E4%B8%80%E9%A1%B5%E5%A4%9A%E5%9B%BE%E7%8B%AC%E7%AB%8B%E5%9B%BE/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-07-15-ggplot2%E4%B8%80%E9%A1%B5%E5%A4%9A%E5%9B%BE%E7%8B%AC%E7%AB%8B%E5%9B%BE/</guid>
      <description>方法一: 使用grid包 方法二: 使用patchwork包 使用plot_layout()函数调整页面布局 图表之间添加或删除空格–plot_spacer() 在一个页面上自由组合各种图(可以毫无关联)，省空间，又能表达自己需求。
require(ggplot2) require(grid) #####现将图画好，并且赋值变量，储存##### p1 &amp;lt;- ggplot(mtcars, aes(mpg, wt, colour = factor(cyl))) + geom_point() p2 &amp;lt;- ggplot(diamonds, aes(carat, depth, colour = color)) + geom_point() p3 &amp;lt;- ggplot(diamonds, aes(carat, depth, colour = color)) + geom_point() + facet_grid(.~color,scale = &amp;quot;free&amp;quot;) p1 p2 p3 这里有三张图p1,p1,p3，我想把它输出到一个页面上，不单独输出，可以用一些方法
方法一: 使用grid包 ########新建画图页面########### grid.newpage() ##新建页面 pushViewport(viewport(layout = grid.layout(2,2))) ####将页面分成2*2矩阵 vplayout &amp;lt;- function(x,y){ viewport(layout.pos.row = x, layout.pos.col = y) } print(p3, vp = vplayout(1,1:2)) ###将（1,1)和(1,2)的位置画图p3 print(p2, vp = vplayout(2,1)) ###将(2,1)的位置画图p2 print(p1, vp = vplayout(2,2)) ###将（2,2)的位置画图p1 #dev.</description>
    </item>
    
    <item>
      <title>猫眼电影票房抓取</title>
      <link>/md/2018-07-15-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8A%93%E5%8F%96/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-07-15-%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8A%93%E5%8F%96/</guid>
      <description>猫眼电影票房抓取 基本设置 library(RSelenium) library(stringr) setwd(&amp;#34;C:\\RSelenium&amp;#34;) ######## 初始化浏览器#### remDr &amp;lt;- remoteDriver( browserName = &amp;#34;chrome&amp;#34;, # 浏览器可以自己设置firefox、chrome、phantomjs（要配置） remoteServerAddr = &amp;#34;localhost&amp;#34;, port = 4444L) remDr$open() # 打开浏览器 #&amp;gt; [1] &amp;#34;Connecting to remote server&amp;#34; #&amp;gt; $applicationCacheEnabled #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $rotatable #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $mobileEmulationEnabled #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $networkConnectionEnabled #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $chrome #&amp;gt; $chrome$chromedriverVersion #&amp;gt; [1] &amp;#34;2.37.544315 (730aa6a5fdba159ac9f4c1e8cbc59bf1b5ce12b7)&amp;#34; #&amp;gt; #&amp;gt; $chrome$userDataDir #&amp;gt; [1] &amp;#34;C:\\Users\\zsc\\AppData\\Local\\Temp\\scoped_dir10136_5944&amp;#34; #&amp;gt; #&amp;gt; #&amp;gt; $takesHeapSnapshot #&amp;gt; [1] TRUE #&amp;gt; #&amp;gt; $pageLoadStrategy #&amp;gt; [1] &amp;#34;normal&amp;#34; #&amp;gt; #&amp;gt; $databaseEnabled #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $handlesAlerts #&amp;gt; [1] TRUE #&amp;gt; #&amp;gt; $hasTouchScreen #&amp;gt; [1] FALSE #&amp;gt; #&amp;gt; $version #&amp;gt; [1] &amp;#34;67.</description>
    </item>
    
    <item>
      <title>相关图之corrgram</title>
      <link>/md/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bcorrgram/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bcorrgram/</guid>
      <description>相关图： 所谓相关图是基于变量间的相关系数大小，通过可视化方法反应不同变量组合间相关关系的差异图形。可以把相关图分为相关矩阵图、相关层次图
相关矩阵图 R语言中，绘制相关矩阵图的包主要有两个：corrgram::corrgram和corrplot::corrplot
此处都以mtcars数据集为例，说明这两个函数的使用
相关矩阵图一—–corrgram corrgram::corrgram()函数 corrgram(x, type = NULL, order = FALSE, labels, panel = panel.shade, lower.panel = panel, upper.panel = panel, diag.panel = NULL, text.panel = textPanel, label.pos = c(0.5, 0.5), label.srt = 0, cex.labels = NULL, font.labels = 1, row1attop = TRUE, dir = &amp;quot;&amp;quot;, gap = 0, abs = FALSE, col.regions = colorRampPalette(c(&amp;quot;red&amp;quot;, &amp;quot;salmon&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;royalblue&amp;quot;, &amp;quot;navy&amp;quot;)), cor.method = &amp;quot;pearson&amp;quot;, outer.labels = NULL, ...) 参数解释： x: 数据框或者相关矩阵,输入数据框时，会自动识别数值型列进行计算相关矩阵，然后再绘图 order: 是否让变量按主成分分析相关矩阵排列.</description>
    </item>
    
    <item>
      <title>相关图之corrplot</title>
      <link>/post/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bcorrplot/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bcorrplot/</guid>
      <description>相关矩阵图二—–corrplot corrplot::corrplot()函数 由于corrgram::corrgram()函数没有显示相关性的大小度量关系，于是经常用corrplot::corrplot()函数来画相关矩阵图，不过此图的缺点是title画出来不好看
corrplot(corr, method = c(&amp;quot;circle&amp;quot;, &amp;quot;square&amp;quot;, &amp;quot;ellipse&amp;quot;, &amp;quot;number&amp;quot;, &amp;quot;shade&amp;quot;,&amp;quot;color&amp;quot;, &amp;quot;pie&amp;quot;), type = c(&amp;quot;full&amp;quot;, &amp;quot;lower&amp;quot;, &amp;quot;upper&amp;quot;), add = FALSE, col = NULL, bg = &amp;quot;white&amp;quot;, title = &amp;quot;&amp;quot;, is.corr = TRUE, diag = TRUE, outline = FALSE, mar = c(0, 0, 0, 0), addgrid.col = NULL, addCoef.col = NULL, addCoefasPercent = FALSE, order = c(&amp;quot;original&amp;quot;, &amp;quot;AOE&amp;quot;, &amp;quot;FPC&amp;quot;, &amp;quot;hclust&amp;quot;, &amp;quot;alphabet&amp;quot;), hclust.method = c(&amp;quot;complete&amp;quot;, &amp;quot;ward&amp;quot;, &amp;quot;ward.D&amp;quot;, &amp;quot;ward.D2&amp;quot;, &amp;quot;single&amp;quot;, &amp;quot;average&amp;quot;, &amp;quot;mcquitty&amp;quot;, &amp;quot;median&amp;quot;, &amp;quot;centroid&amp;quot;), addrect = NULL, rect.</description>
    </item>
    
    <item>
      <title>相关图之ggplot系列扩展1</title>
      <link>/post/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bggplot%E6%89%A9%E5%B1%951/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bggplot%E6%89%A9%E5%B1%951/</guid>
      <description>由于corrplot包画图存在一些问题，比如图像不美观，以及title显示不出，等等
于是有了ggplot2 的扩展系列
ggcorrplot包 专门画相关系数矩阵图： https://github.com/kassambara/ggcorrplot
GGally 包： 对ggplot2进行了更多的扩展，其中包括相关系数图： http://ggobi.github.io/ggally/index.html#alterations
ggcorrplot包 library(ggcorrplot) library(purrr) data(mtcars) corr &amp;lt;- cor(mtcars) # 相关系数矩阵 corr %&amp;gt;% head() #&amp;gt; mpg cyl disp hp drat wt #&amp;gt; mpg 1.0000000 -0.8521620 -0.8475514 -0.7761684 0.6811719 -0.8676594 #&amp;gt; cyl -0.8521620 1.0000000 0.9020329 0.8324475 -0.6999381 0.7824958 #&amp;gt; disp -0.8475514 0.9020329 1.0000000 0.7909486 -0.7102139 0.8879799 #&amp;gt; hp -0.7761684 0.8324475 0.7909486 1.0000000 -0.4487591 0.6587479 #&amp;gt; drat 0.6811719 -0.6999381 -0.7102139 -0.4487591 1.0000000 -0.7124406 #&amp;gt; wt -0.</description>
    </item>
    
    <item>
      <title>相关图之ggplot系列扩展2</title>
      <link>/post/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bggplot%E6%89%A9%E5%B1%952/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-07-15-%E7%9B%B8%E5%85%B3%E5%9B%BE%E4%B9%8Bggplot%E6%89%A9%E5%B1%952/</guid>
      <description>由于corrplot包画图存在一些问题，比如图像不美观，以及title显示不出，等等
于是有了ggplot2 的扩展系列
ggcorrplot包 专门画相关系数矩阵图： https://github.com/kassambara/ggcorrplot
GGally 包： 对ggplot2进行了更多的扩展，其中包括相关系数图： http://ggobi.github.io/ggally/index.html#alterations
GGally::ggcorr()函数 介绍 该ggcorr函数是一个可视化函数，用于将相关矩阵绘制为ggplot2对象。它的灵感来自Stack Overflow问题。
解释 相关矩阵显示了相对大量的连续变量之间的相关系数。然而，虽然R提供了一种通过cor函数创建这种矩阵的简单方法，但它没有为该函数创建的矩阵提供绘图方法。
该ggcorr功能提供了这样的绘图方法，使用ggplot2包中实现的“图形语法” 来渲染绘图。在实践中，其结果在图形上接近corrplot功能的结果，这是优秀arm包装的一部分。
安装 install.packages(&amp;quot;GGally&amp;quot;) # 或者 source(&amp;quot;https://raw.githubusercontent.com/briatte/ggcorr/master/ggcorr.R&amp;quot;) 依赖 主要的包依赖ggcorr是ggplot2用于绘图构造的包。
library(ggplot2) 该ggplot2软件包可以从被安装CRAN通过install.packages。这样做也将安装reshape2包，内部ggcorr用于数据操作。
library(GGally) ggcorr(mtcars) ggcorr(iris) # ggcorr会自动挑选数值型变量进行画图,它还产生一个警告，指示数据集的一列不包含数字数据，因此从相关矩阵中删除。从传递给的数据集中删除列可以避免警告， eg: ggcorr(iris[,-5]) #&amp;gt; Warning in ggcorr(iris): data in column(s) &amp;#39;Species&amp;#39; are not numeric and were #&amp;gt; ignored 注意：当与连续色标一起使用时，ggcorr当前也会产生与色彩插值相关的警告。这是一个无害的警告，应该在未来的更新ggplot2和scales包中消失。此警告隐藏在此小插图的其余部分中。
ggcorr(mtcars)# 默认接受数据框，矩阵 ## 可接受相关系数矩阵 ## ggcorr支持cor函数提供的所有相关方法。参考cor()函数: ## cor(x, y = NULL, use = &amp;quot;everything&amp;quot;,method = c(&amp;quot;pearson&amp;quot;, &amp;quot;kendall&amp;quot;, &amp;quot;spearman&amp;quot;)) ggcorr(data = NULL, cor_matrix = cor(mtcars, use = &amp;quot;everything&amp;quot;)) 控制图例的颜色块 默认图例颜色是连续的，</description>
    </item>
    
    <item>
      <title>泰坦尼克号预测(kaggle)</title>
      <link>/md/2018-07-14-kaggle-%E6%B3%B0%E5%9D%A6/</link>
      <pubDate>Sat, 14 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-07-14-kaggle-%E6%B3%B0%E5%9D%A6/</guid>
      <description>options(width = 300) knitr::opts_chunk$set(message = F,warning = F,comment = &amp;#34;#&amp;gt;&amp;#34;,collapse = TRUE) 读入数据 library(data.table) train=fread(&amp;quot;data/train.csv&amp;quot;,na.strings = c(&amp;quot;&amp;quot;,NA)) test=fread(&amp;quot;data/test.csv&amp;quot;,na.strings = c(&amp;quot;&amp;quot;,NA)) #把两个合并起来进行数据处理--两个data.table的合并 combine =rbindlist(list(train,test),fill=TRUE) #### 其实个人不建议这样操作，因为不能把测试集和训练集一起处理，应该分开处理 数据处理 # 统计每一列的缺失率 combine[,lapply(.SD, function(x)sum(is.na(x)))] #&amp;gt; PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked #&amp;gt; 1: 0 418 0 0 0 263 0 0 0 1 1014 2 # 可以看出 我们需要对缺失列进行处理，以及一些特征衍生工作 library(zoo) library(purrr) combine[,Age := na.spline(Age)] # age变量进行处理，进行样条插补 combine[,Fare := na.spline(Fare)] # Fare变量进行处理，进行样条插补 由于Cabin 变量丢失数据太多，于是可以删除这个变量</description>
    </item>
    
    <item>
      <title>seq*函数族</title>
      <link>/md/2018-07-08-seq%E5%87%BD%E6%95%B0%E6%97%8F/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-07-08-seq%E5%87%BD%E6%95%B0%E6%97%8F/</guid>
      <description>seq(from = 1, to = 1, by = 步长（默认为1),length.out = NULL, along.with = NULL, ...) seq.int(from, to, by, length.out, along.with, ...) seq_along(along.with) seq_len(length.out) from：生成向量的起点， to：生成向量的终点，默认步长为1（可修改） length.out：向量中元素数目 along.with：表示生成的向量为现有一向量元素的索引 主要介绍seq_along(along.with) 和seq_len(length.out)函数，应用于循环中
比如:
# 要循环某个向量长度的次数,比如向量a，其长度未知 for(i in seq_along(a)){...} 代替 for(i in 1:length(a)){...} ## 经常犯这样的错误，不美观 # 循环中，循环1:10可以用一下方法 for(i in seq_len(10)){...} 代替 for(i in 1:10){...} head(x,5) : 取向量的前5个元素，向量 ，数据框 ，list都适用
tail(x,5): 取向量的后5个元素，等价 x[-(1:(length(x)-5))] 等价 x[(length(n-4):length(n)] </description>
    </item>
    
    <item>
      <title>正则表达式(通用)</title>
      <link>/md/2018-05-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9A%E7%94%A8/</link>
      <pubDate>Sat, 19 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-05-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%9A%E7%94%A8/</guid>
      <description>正则表达式&amp;ndash;表格 注意： 由于每个软件的正则表达式的转义字符是不一样的，比如R中一般用\\.来代表匹配小数点. 表格中的\ ，但在软件中可能需要\\才能表达出来，eg:\d 匹配任意一个数字， 可能需要使用\\d 1. 基本的元字符 元字符 说明 . 匹配任意单个字符，字母、数字甚至是.字符本身 | 逻辑或操作符 [ ] 匹配该字符集合中的一个字符（各个字符之间是or关系） **注意: ** [.] 只匹配点本身,不是特殊字符,不用转义. [^ ] 对字符集合求非就是排除该字符集合[^0-9] ： 匹配任何不适数字的字符 - 定义一个区间,[A-Za-z09]: 匹配(大小)字母和数字-只有出现在[]之间才是元字符-出现在其他地方，则表示一个普通字符 \ 对下一个字符进行转义 2. 数量元字符 元字符 说明 * 匹配前一个字符(或字符集合或子表达式)的零次或多次重复 + 匹配前一个字符(或字符集合或子表达式)的一次或多次重复 ? 匹配前一个字符(或字符集合或子表达式)的零次或一次重复 *? * 的懒惰型版本 +? +的懒惰型版本 {n} 匹配前一个字符(或字符集合或子表达式)的n次重复 {m,n} 匹配前一个字符(或字符集合或子表达式)至少m次且至多n次重复 {n, } 匹配前一个字符(或字符集合或子表达式)n次重复或更多次重复（至少n次） {n, }? {n, }的懒惰型版本 3. 位置元字符 元字符 说明 ^ 匹配字符串的开头 $ 匹配字符串的结束 \A 匹配字符串的开头（大多数语言不支持, 类似^） \Z 匹配字符串的结束（大多数语言不支持, 类似$） \&amp;lt; 匹配单词的开头（是\b的更细粒度控制，支持的语言并不多见） \&amp;gt; 匹配单词的结束（是\b的更细粒度控制，支持的语言并不多见） \b 匹配单词的边界（开头或结束）eg: \bcap\b: 表示匹配cap这个完整单词.</description>
    </item>
    
    <item>
      <title>R中时间类型概念</title>
      <link>/md/2018-04-14-r%E4%B8%AD%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sat, 14 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-14-r%E4%B8%AD%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E6%A6%82%E5%BF%B5/</guid>
      <description>基本类型介绍 在R中，所有有关时间和日期的类(包),都可以处理日历时间(eg:2018年4月13日)，只有某些特定的类才能处理日期时间类型(eg:2018年4月13日 下午6:45)
类 处理类型 说明 强制转换 R所在包 Date类 日历日期 实际存储的为数字，是从1970年1月1日算起到该时间以天计算的一个数值.eg: &amp;ldquo;2018-04-13&amp;rdquo; as.Date() 基本函数 POSIXct类 日期时间 实际存储的为数字，是从1970年1月1日算起到该时间以秒计算的一个数值.eg: &amp;ldquo;2018-04-13 19:47:18 CST&amp;rdquo;个人建议使用这个，存储数据 as.POSIXct() 基本函数 POSIXlt类 日期时间 实际存储为含有9个元素的列表,其中包括年、月、日、小时、分钟、秒。eg: &amp;ldquo;2018-04-13 19:47:18 CST&amp;rdquo;存储非结构化数据 as.POSIXlt() 基本函数 Date类 日历日期 同上 as_date() lubridate包 POSIXct类 日期时间 同上 as_datetime() lubridate包 difftime类 时间 实际存储的为数字，是从当天00:00:00算起到该时间以秒计算的一个数值.eg:&amp;ldquo;00:01:25&amp;rdquo; hms::as.hms(85) lubridate包 在实际工作中，只要满足要求，尽量适用比较简单的类型，先考虑Date ，在考虑POSIXct
R中处理时间序列的包： chron ： 常用于计量经济学和时间序列分析中
lubridate： 推荐,特别适用于处理日期时间算法
mondate: 特别适用于处理以月为单位的日期，（会计和精算工作中常用）
timeDate： 很强大，对时间精度要求高的话，可以考虑
时间的基本用法 字符串转换为日期： as.Date(x ,format=&amp;quot;%m/%d/%y&amp;quot;) ,建议format参数不能省，否则有时会出错
日期转化为字符串: as.characher() 或者 format()
把日期（Date类和POSIXct类）转换为整数 ： unclass(x)或者 as.integer(x)</description>
    </item>
    
    <item>
      <title>R 语言并行化计算之foreach包</title>
      <link>/md/2018-04-08-r%E8%AF%AD%E8%A8%80%E5%B9%B6%E8%A1%8C%E5%8C%96%E8%AE%A1%E7%AE%97%E4%B9%8Bforeach%E5%8C%85/</link>
      <pubDate>Sun, 08 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-08-r%E8%AF%AD%E8%A8%80%E5%B9%B6%E8%A1%8C%E5%8C%96%E8%AE%A1%E7%AE%97%E4%B9%8Bforeach%E5%8C%85/</guid>
      <description>foreach包执行任务的核心理念与传统的apply组函数基本一致，都是与split – apply – combine一致的流程，不过foreach比传统apply组函数的优越之处在于，它可以通过调用操作系统的多核运行性能来执行并行任务，这样特别是对于I/O密集型任务而言，可以大大节省代码执行效率。
解读foreach()函数
library(&amp;#34;doParallel&amp;#34;) #加载doParallel包用于之后注册进程 library(&amp;#34;foreach&amp;#34;) #导入foreach包 ######################################################################## ########## foreach()函数主要是对原本的for循环进行并行运算 ############### ######################################################################### #############并行化格式 detectCores() #这个网上说是核数，但实际上是线程数，和真实的物理核多一倍，4核8线程 cl&amp;lt;- makeCluster(detectCores()) # 不过R中能运行满线程 ，即detectCores()返回的核数。 registerDoParallel(cl) #进行进程注册 mydata1 &amp;lt;- foreach( ..., # 并行化参数（循环参数）,当参数为两个以上时，选长度较短的循环完为止. .combine, #合并方式，default是list，“c”返回vector,cbind和rbind返回矩阵,也可以自定义函数. # &amp;#34;+&amp;#34;和&amp;#34;*&amp;#34;是対返回后的list进行同列操作 .init, #.combine函数的第一个变量,当.combine参数被具体化是才用 .final=NULL, #返回最后结果 .inorder=TRUE,#返回和原始输入相同顺序的结果 .multicombine=FALSE,#设定.combine函数的传递参数，FALSE表示其参数是2，TRUE可以设定多个参数 .maxcombine=if (.multicombine) 100 else 2, #设定.combine的最大参数 .errorhandling=c(&amp;#39;stop&amp;#39;, &amp;#39;remove&amp;#39;, &amp;#39;pass&amp;#39;),#如果循环中出现错误，对错误的处理方法 .packages=NULL,# 指定在%dopar%运算过程中依赖的package（%do%会忽略这个选项）。 .export=NULL, # 在编译函数的时候需要预先加载一些内容进去，类似parallel的clusterExport .noexport=NULL, .verbose=FALSE) ##是否打印运行信息 ) %dopar% {***} #并行的代码，也可以是相应的函数,即我们for循环的函数体 stopCluster(cl) # 结束集群 注意：平时我们大多数使用时，很多参数都选取默认状态，其中常用参数为：... 、.combine、.packages.
基本操作
library(&amp;#34;doParallel&amp;#34;) #加载doParallel包用于之后注册进程 library(&amp;#34;foreach&amp;#34;) #导入foreach包 cl&amp;lt;- makeCluster(detectCores()-1) registerDoParallel(cl) #进行进程注册 getDoParWorkers() # #查看注册了多少个核 code=function(){ x1&amp;lt;-(a + b); x2&amp;lt;-a*b; c(x1,x2); } # 并行化参数,当参数为两个以上时，选长度较短的循环完为止.</description>
    </item>
    
    <item>
      <title>RSelenium应用--京东商品</title>
      <link>/md/2018-04-07-rselenium%E5%BA%94%E7%94%A8%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81/</link>
      <pubDate>Sat, 07 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-07-rselenium%E5%BA%94%E7%94%A8%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81/</guid>
      <description>library(RSelenium) library(stringr) setwd(&amp;#34;E:\\rwork\\Rselenium&amp;#34;) ######## 初始化浏览器#### remDr &amp;lt;- remoteDriver( browserName = &amp;#34;chrome&amp;#34;, # 浏览器可以自己设置firefox、chrome、phantomjs（要配置） remoteServerAddr = &amp;#34;localhost&amp;#34;, port = 4444L) # 默认情况下，Selenium Server侦听端口为4444 remDr$open() # 打开浏览器 # remDr$getStatus() ## 使用该status方法查询远程服务器的状态。 url=&amp;#34;https://www.baidu.com/&amp;#34; remDr$navigate(url) # navigate方法打开网页，url一定要完整 ## remDr$getCurrentUrl() # 获取当前页面的url ###########################进行搜索关键词 ##### 按属性--属性值搜索 ,可以是css,xpath ,id ,属性等 对应值 webElem &amp;lt;- remDr$findElement(using = &amp;#39;css&amp;#39;, &amp;#34;#kw&amp;#34;) # 找到这个元素--进行搜索关键词 webElem$sendKeysToElement(list(&amp;#34;京东&amp;#34;,key=&amp;#34;enter&amp;#34;)) #### 获取当前页面的所有标题，每个链接的标题都包含在&amp;lt;h3 class = &amp;#34;t&amp;#34;&amp;gt;标签中。我们将h3首先访问标题 #### 注意 findElements和 findElement方法是获取一个或者多个的区别 webElems &amp;lt;- remDr$findElements(using = &amp;#39;css&amp;#39;, &amp;#34;h3.t&amp;#34;) resHeaders &amp;lt;- unlist(lapply(webElems, function(x){x$getElementText()})) # resHeaders ######################## 鼠标点击事件 webElem&amp;lt;-remDr$findElement(using = &amp;#34;css&amp;#34;,&amp;#34;#w-f80518 &amp;gt; div &amp;gt; h2 &amp;gt; a.</description>
    </item>
    
    <item>
      <title>利用RSelenium包模拟浏览器爬取网页信息</title>
      <link>/md/2018-04-06-rselenium/</link>
      <pubDate>Fri, 06 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-06-rselenium/</guid>
      <description>1.背景介绍： 现在很多网页都采用AJAX这种异步加载的网页结构，简单的页面爬取不了这些数据
例如：
2、这是需要R包&amp;mdash;RSelenium包
使用RSelenium包的准备
0、JAVA 环境的准备 ，安装是否成功可以进行xlsx包进行测试
1、Chrome驱动 下载,注意chrome驱动一定要和chrome浏览器对应 ,比如我的浏览器 65.0.3325.181 ，对应表放在文章最后,或者点击这里,,怎么查看浏览器版本，点击谷歌浏览器右上【&amp;hellip;】&amp;mdash;【帮助】&amp;ndash;【关于Google Chrome】就可以看到浏览器版本了。
2、Selenium Standalone Server下载 我用的是 selenium-server-standalone-3.11.0.jar
3、PhantomJS下载 ,无头浏览器。(这个个人需要的话就下载，我用Google浏览器就够了)
2、安装流程： 使用前的基本配置 首先，安装JAVA JDK 1.8。
然后，安装Chrome（最新版本）。
之后，把解压后的ChromeDriver.exe（最新版本）放在Chrome的安装路径下。一定要和chrome.exe放在同一个目录下面。例如
把chromedriver.exe所在目录的路径(建议放在和chrome.exe)放入环境变量中即可,
基本配置基本完成
3、RSelenium使用与实例 3.1、使用前的基础步骤 1、首先 ，打开cmd ，切换到 selenium-server-standalone-3.0.1.jar文件所在的位置，我的都在C:\RSelenium这个目录下 ，切换以后 ，运行
java -jar selenium-server-standalone-3.11.0.jar
显示 ：
或者直接在Rstudio中运行system(&#39;java -jar &amp;quot;C:/RSelenium/selenium-server-standalone-3.11.0.jar&amp;quot;&#39;,wait = FALSE)代码即可。
2、运行后，最小化，不要关闭，在打开Rstudio,
3、通过R调用Selenium Server并打开网页，对页面进行点击，选取相应条件。通过RSelenium与rvest共同爬取数据。通过 一步一步解读Rcode来解释这一过程。
3.2、案例1 浏览器的基本操作
library(RSelenium) library(stringr) setwd(&amp;#34;C:\\RSelenium&amp;#34;) ######## 初始化浏览器#### remDr &amp;lt;- remoteDriver( browserName = &amp;#34;chrome&amp;#34;, # 浏览器可以自己设置firefox、chrome、phantomjs（要配置） remoteServerAddr = &amp;#34;localhost&amp;#34;, port = 4444L) remDr$open() # 打开浏览器 remDr$getStatus()# 使用该status方法查询远程服务器的状态。 # 关闭浏览器 # remDr$quit() # 直接退出 # remDr$close() # close用于关闭当前会话，也可以用作关闭浏览器 **访问DOM中的元素 **</description>
    </item>
    
    <item>
      <title>R语言字符处理---基本函数</title>
      <link>/md/2018-04-05-r%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86---%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-05-r%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86---%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/</guid>
      <description>R语言字符处理&amp;mdash;基本函数 函数 说明 Encoding(x) Encoding(x) &amp;lt;- value enc2native(x) enc2utf8(x) 读取或设置字符向量的编码常结合iconv(x, from = &amp;ldquo;&amp;rdquo;, to = &amp;ldquo;&amp;quot;)函数使用注意：Encoding(x) &amp;lt;- value 这是一种赋值函数 nchar(x, type = &amp;ldquo;chars&amp;rdquo;, allowNA = FALSE, keepNA = NA)nzchar(x, keepNA = FALSE) nchar()返回字符长度nzchar()判断是否空字符keepNA为真是NA保留，不计入计数对于缺失值NA，nchar和nzchar函数默认是字符数为2的字符串。对于NULL，nchar和nzchar函数会忽略掉。 substr(x, start, stop)substring(text, first, last = 1000000L)substr(x, start, stop) &amp;lt;- valuesubstring(text, first, last = 1000000L) &amp;lt;- value 提取或替换字符向量的子字段，substring同substr功能一样 strtrim(x, width) 按显示宽度截断字符串 paste (&amp;hellip;, sep = &amp;quot; &amp;ldquo;, collapse = NULL)paste0(&amp;hellip;, collapse = NULL) 通过sep连接间隔连接对象,返回字符串向量设定collapse的话，会通过collapse连接间隔将上一步的字符串向量连接成一个字符串 strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE) 基于split子句分割字符向量xfixed为TRUE的话，完全匹配split；否则，基于正则表达式。可以使用split=NULL来分割每个字符。 chartr(old, new, x) 将x中的字符old变换为字符new注意替换的是单个对应的字符，而非字符串 tolower(x)toupper(x) 大小写转换 sprintf(fmt, &amp;hellip;) 系统C库函数sprintf封装器，格式化输出函数 正则表达式&amp;mdash;&amp;ndash;字符串匹配函数 函数 说明 grep(pattern, x, ignore.</description>
    </item>
    
    <item>
      <title>R语言字符处理函数包---stringr包</title>
      <link>/md/2018-04-05-r%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E5%A4%84%E4%B9%8Bstringr%E5%8C%85/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-04-05-r%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E5%A4%84%E4%B9%8Bstringr%E5%8C%85/</guid>
      <description>1.stringr介绍 stringr包被定义为一致的、简单易用的字符串工具集。所有的函数和参数定义都具有一致性，比如，用相同的方法进行NA处理和0长度的向量处理。
字符串处理虽然不是R语言中最主要的功能，却也是必不可少的，数据清洗、可视化等的操作都会用到。对于R语言本身的base包提供的字符串基础函数，随着时间的积累，已经变得很多地方不一致，不规范的命名，不标准的参数定义，很难看一眼就上手使用。字符串处理在其他语言中都是非常方便的事情，R语言在这方面确实落后了。stringr包就是为了解决这个问题，让字符串处理变得简单易用，提供友好的字符串操作接口。
2.stringr的API介绍 stringr包常用的字符串的处理以str_开头来命名，方便更直观理解函数的定义。我们可以根据使用习惯对函数进行分类：
字符串拼接函数 函数 说明 R Base中对应函数 str_c()str_join() 同str_c() 字符串拼接 paste(),paste0() str_trim()) 去掉字符串的空格和TAB(\t) str_pad() 用pad参数填充字符串的长度，长度自己设定 str_dup() 复制字符串 str_wrap() 控制字符串输出格式 strtrim() str_sub()str_sub() &amp;lt;- value 截取字符串抽取或替换正则表达式匹配子串 regmatches()regmatches() &amp;lt;- value 字符串计算函数 函数 说明 R Base中对应函数 str_count() 字符串计数，返回指定匹配出现的次数 str_length() 返回字符的长度 nchar() str_sort() 对字符值进行排序 str_order() 字符串索引排序， 字符串匹配函数 函数 说明 R Base中对应函数 str_split()str_split_fixed() 同上 按照模式分割字符串 strsplit() str_match()str_match_all() 从字符串中提取首个匹配组 str_replacestr_replace_all 替换首个匹配模式 sub()gsub() str_replace_na() 把NA替换为NA字符串 str_locate()str_locate_all() 返回首个匹配模式的字符的位置 regexpr()gregexpr() str_extract()str_extract_all() 提取首个匹配模式的字符 str_subset() 返回匹配的字符串 str_detect() 检测字符是否存在某些指定模式 grepl() word() 从文本中提取单词 字符串变换函数 函数 说明 R Base中对应函数 str_conv() 字符编码转换,基本函数中的比较好用 iconv(x, from = &amp;ldquo;&amp;rdquo;, to = &amp;ldquo;&amp;rdquo;) str_to_upper()str_to_lower() 字符串转成大写/小写 tolower(x)toupper(x) str_to_title()同大小写转换 字符串转成首字母大写 参数控制函数， 仅用于构造功能的参数，不能独立使用。</description>
    </item>
    
    <item>
      <title>R计算微积分</title>
      <link>/post/test-toc/</link>
      <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/test-toc/</guid>
      <description>(一)R 计算微积分 1.1差分 x=1:12 diff(x) #向量差分 后面一个数减去前面一个数 ## [1] 1 1 1 1 1 1 1 1 1 1 1 z=matrix(x,3,4) z ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 diff(z) #矩阵差分 前行减去后行 ## [,1] [,2] [,3] [,4] ## [1,] 1 1 1 1 ## [2,] 1 1 1 1 1.2 符号计算–微分 1.2.1求一元函数导数— \(\sin{x}\) 的一阶导数为： \(\cos{x}\) 在R里，声明表达式对象使用 expression() 函数, 计算一阶导数用D()函数,格式：D(表达式,对谁求导)</description>
    </item>
    
    <item>
      <title>data.table -- 2基本概念</title>
      <link>/md/2018-01-17-datatable2/</link>
      <pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-01-17-datatable2/</guid>
      <description>data.table基本概念和其余函数&amp;mdash;还需要修改 set* 函数族 会改变原有的数据，没有返回值，在data.table里，操作符&amp;quot;:=&amp;quot;和所有的以set开头函数（比如setkey,setorder,setname等）一样，它们都会更新输入的原数据。
library(data.table) iris_dt = data.table(iris) # setnames(DT,oldnames,newnames) # 改变DT的列名oldnames,newnames为向量即变量 #改变列的顺序 col_names = colnames(iris_dt) setcolorder(iris_dt,col_names[5:1]) # 更改某行某列的值,即更新元素的值 set(iris_dt,1,1,NA)# 更改1行1列的值为NA 1、键（主键）的概念 data.table从来不使用行名。data.table类似有行名的形式为1:，2: , ... 主键会对筛选的列进行重排序 我们把data.table数据中的行名叫做键（或主键），他类似于python的字典，使用键值对类型查找数据，键要求唯一，每一行有且只有一个键。但是R中的键可以用多个甚至可以重复，键就相当于索引，通过键进行数据的查找 setkey() 和 setkeyv()可以直接更新输入的data.table，就和上一讲中的操作符&amp;quot;:=&amp;ldquo;一样。它们没有返回值。 这个主键和其它语言不一样，例如python的键，唯一，在r中任意列都能使用setkey()来设置主键 library(data.table) mtcars_dt &amp;lt;- data.table(mtcars) # 可以看出mtcars数据集中的行名没有了，替而代之为1: ，2: # 若想保留行名，设置keep.rownames = T，当keep.rowname＝&amp;#34;new&amp;#34;时，列名改为new即可 mtcars_dt &amp;lt;- data.table(mtcars,keep.rownames = T)#默认创建一个叫做 rn的列，并且将行名赋值给这一列。 mtcars_dt 1.2、设置／获取／使用主键 怎么将数据中的某一列设置为主键呢？&amp;mdash;setkey()函数
setkey(DT, key) 将DT中的key列设置为主键，但是类行名 1:，2:,&amp;hellip;,不会发生改变, 上面等价 setkeyv(DT, &amp;quot;key&amp;quot;) ，也将DT中的key列设置为主键 一旦将某一列设置成data.table的主键，就可以在参数i里指定 .()来subset那些主键了(就可以进行行筛选了)。我们还是用mtcars数据集，我们增加一个新列new mtcars_dt &amp;lt;- data.table(mtcars) mtcars_dt[,new:=Sys.Date()+1:32] #增加一列new，内容为时间 setkey(mtcars_dt,new) mtcars_dt # 类似行名并没有发生改变， mtcars_dt[.</description>
    </item>
    
    <item>
      <title>data.table -- 1基本函数</title>
      <link>/md/2018-01-16-datatable1/</link>
      <pubDate>Tue, 16 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-01-16-datatable1/</guid>
      <description>data.table本质上是一个list，它们的列包含的元素个数都相同。
1、数据的读写 1.1数据读入－－fread 选其常用的参数如下：
fread(input,na.strings=&amp;#34;NA&amp;#34;, file, stringsAsFactors=FALSE,encoding=&amp;#34;unknown&amp;#34;, ...) input 入的文件对象，fread函数可以自动判断分隔符类型，自动判断首行是否是列标题，同时默认读入时字符型变量不会变为因子型。也可也从网页读取数据 na.strings,对NA的解释； file文件路径，再确保没有执行shell命令时很有用，也可以在input参数输入; stringsASFactors是否转化字符串为因子， encoding，默认&amp;quot;unknown&amp;quot;，其它可能&amp;quot;UTF-8&amp;quot;或者&amp;quot;Latin-1&amp;quot;，不是用来重新编码的，而是允许处理的字符串在本机编码; showProgress = T 显示进度条 integer64 当数据列中有大于2 ^ 31的整数,可能会丢失精度 quote 对带双引号的字符添加转义,在R中正常显示,但是输出时,可能会引起成倍的双引号,因此建议使用fwrite时,设置该参数quote = FALSE 1.2数据写入－－fwrite fwrite(x, file = &amp;#34;&amp;#34;, append = FALSE, na = &amp;#34;&amp;#34;, row.names = FALSE, col.names = TRUE,logicalAsInt = FALSE, ...) x,比如data.frame和data.table等R的对象； file，输出文件名,&amp;ldquo;&amp;ldquo;意味着直接输出到操作台； append，如果TRUE,在原文件的后面添加；默认删除原来文件的数据，重新存储。 na,na值的表示，默认&amp;rdquo;&amp;quot;； row.names，是否写出行名，因为data.table没有行名，所以默认FALSE； col.names ，是否写出列名，默认TRUE，如果没有定义，并且append=TRUE和文件存在，那么就会默认使用FALSE; logicalAsInt,逻辑值作为数字写出还是作为FALSE和TRUE写出； 1.3 数据框转为data.table 对于数据的处理，data.table包提供了一个非常简洁的通用格式：DT[i,j,by]，
其中i控制列, j控制列, by控制分组. 上述表达式的意思是: 对于数据集DT，先选取子集行i, 然后通过by分组计算j。i设定数据的选取条件，j设定结果的计算方式，by设定数据的分组情况。通过这个，我们可以在一行代码中很方便地完成处理过程。首先需要把数据变为data.table类型 library(data.table) library(magrittr) ### 方法一: 赋值转换 mtcars_dt &amp;lt;- data.</description>
    </item>
    
    <item>
      <title>因子数据类型处理</title>
      <link>/post/2018-01-14-factor/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-01-14-factor/</guid>
      <description>因子类型 变量可归结为名义型、有序型或连续型变量，
类别（名义型）变量和有序类别（有序型）变量在R中称为因子（factor） ，如性别、省份、职业。
类别（名义型）变量是没有顺序之分的类别变量。
有序型变量表示一种顺序关系，代表有序量度，如打分结果，疾病严重程度等。而非数量关系。
连续型变量可以呈现为某个范围内的任意值，比如年龄
1、基础函数 针对因子型数据，我们一般需要用到三种变化
更改level标签名 更改level顺序 创建有序因子 用factor()函数把字符型向量转换成因子，如
x &amp;lt;- c(&amp;quot;男&amp;quot;, &amp;quot;女&amp;quot;, &amp;quot;男&amp;quot;, &amp;quot;男&amp;quot;, &amp;quot;女&amp;quot;) sex &amp;lt;- factor(x) #将此向量存储为(1, 2, 1, 1，2)，并在内部将其关联为1=&amp;quot;男&amp;quot;和2=&amp;quot;女&amp;quot;（具体赋值根据字母顺序而定）。 sex ## [1] 男 女 男 男 女 ## Levels: 男 女 attributes(sex) ## $levels ## [1] &amp;quot;男&amp;quot; &amp;quot;女&amp;quot; ## ## $class ## [1] &amp;quot;factor&amp;quot; 因子有class属性，取值为&#34;factor&#34;， 还有一个levels(水平值)属性， 此属性可以用levels()函数访问，如
levels(sex)#查看某个因子的标签有哪些 ## [1] &amp;quot;男&amp;quot; &amp;quot;女&amp;quot; 因子的levels属性可以看成是一个映射， 把整数值1,2,…,映射成这些水平值， 因子在保存时会保存成整数值1,2,等与水平值对应的编号。 这样可以节省存储空间， 在建模计算的程序中也比较有利于进行数学运算。
要表示有序型变量，需要为函数factor()指定参数ordered=TRUE。给定向量：
status &amp;lt;- c(&amp;quot;Poor&amp;quot;, &amp;quot;Improved&amp;quot;, &amp;quot;Excellent&amp;quot;, &amp;quot;Poor&amp;quot;) status1 &amp;lt;- factor(status, ordered=TRUE)#会默认关联其值并且按关联的值排序（其实按ascii码表排序）， status1 # 明显可以看出这要的排序并不是我们想要的。 ## [1] Poor Improved Excellent Poor ## Levels: Excellent &amp;lt; Improved &amp;lt; Poor #可以用选项levels自行指定各水平值, 不指定时由x的不同值来求得。 status2 &amp;lt;- factor(status, order=TRUE,levels=c(&amp;quot;Poor&amp;quot;, &amp;quot;Improved&amp;quot;, &amp;quot;Excellent&amp;quot;)) status2 ## [1] Poor Improved Excellent Poor ## Levels: Poor &amp;lt; Improved &amp;lt; Excellent #也可以将数字型变量转为因子变量 ， x &amp;lt;- c(1, 2, 1, 1, 2) (sex=factor(x)) #可以看出，因子水平没有任何区分,可以用labels指定标签 ## [1] 1 2 1 1 2 ## Levels: 1 2 sex &amp;lt;- factor(x, levels=c(1, 2),labels=c(&amp;quot;Male&amp;quot;, &amp;quot;Female&amp;quot;)) #注意到标签的顺序必须和水平相一致 sex ## [1] Male Female Male Male Female ## Levels: Male Female factor()函数的一般形式为</description>
    </item>
    
    <item>
      <title>R软件常见问题</title>
      <link>/md/2018-01-07-%E4%BD%BF%E7%94%A8r%E8%BD%AF%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-01-07-%E4%BD%BF%E7%94%A8r%E8%BD%AF%E4%BB%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>1、读取数据编码问题 读取csv文件出现中文乱码方案，增加编码格式参数
read.csv(trainPath,header=TRUE,stringsAsFactors=TRUE,encoding = &amp;#34;UTF-8&amp;#34;) 保存csv文件中出现乱码，编码格式参数
write.csv(outp, file = path, quote = F, fileEncoding = &amp;#34;UTF-8&amp;#34;) #存储utf-8也乱码，我的电脑有时会发疯，有时又不会 source 加载R脚本中文乱码
source(&amp;#34;core.R&amp;#34;,encoding=&amp;#34;utf-8&amp;#34;) RStudio中脚本中文乱码，编码格式设置：tools -&amp;gt; global option&amp;hellip;., 设置为UTF-8，最后，在打开文件的时候，选择File -&amp;gt; Reopen with encoding菜单，选择我们使用UTF-8编码打开文件，这样子就可以正确地显示中文了。
R语言环境的显示问题
sessionInfo() Sys.getlocale() Sys.setlocale(category = &amp;#34;LC_ALL&amp;#34;,local=&amp;#34;us&amp;#34;) Sys.setlocale(category = &amp;#34;LC_ALL&amp;#34;,local=&amp;#34;chinese&amp;#34;) 2、保存数据编码问题(win中) 由于用Rstudio设置了保存的编码都用UTF-8，所以在保存文件时（特别是csv文件），经常遇到乱码的现象，比如使用data.table:::fwrite()、自带的write.csv()、readr:::write_csv()都乱码
产生的原因：
因为excel打开文件时默认使用unicode的编码方式（还有的网友说是默认以ANSI编码方式打开，待考）。在Unicode基本多文种平面定义的字符（无论是拉丁字母、汉字或其他文字或符号），一律使用2字节储存。恰恰utf-8是1字节的存储方式，所以excel直接打开时会出现乱码。
解决办法：
**方法1、数据导入&amp;ndash;**不建议
打开 Excel，执行“数据”-&amp;gt;“自文本”，选择 CSV 文件，出现文本导入向导，选择“分隔符号”，下一步，勾选“逗号”，去掉“ Tab 键”，下一步，完成，在“导入数据”对话框里，直接点确定。导入之后，所有汉字显示正常，乱码问题解决。
万一这个文本里面的有逗号，巧好分割时候是逗号（csv文件是以逗号进行存储的）,这就会对不齐了，产生新的问题
方法2、先另存再打开
使用记事本打开CSV文件，“文件”-&amp;gt;“另存为”，编码方式选择ANSI，保存完毕后，用EXCEL打开这个文件就不会出现乱码的情况。
不会乱码以后选择另存为excel
方法3、用readr:::write_excel_csv()函数解决
直接用write_excel_csv()这个函数就可以解决上述问题
3、加载java问题 首先下载java ，把java加入环境变量，测试是否安装成功，在cmd命名下输入: java -version,返回
C:\Users\zsc&amp;gt;java -version java version &amp;#34;1.8.0_151&amp;#34; Java(TM) SE Runtime Environment (build 1.</description>
    </item>
    
    <item>
      <title>dplyr -- 3合并数据</title>
      <link>/post/2018-01-04-dplyr3/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-01-04-dplyr3/</guid>
      <description>1、转换与合并 2、筛选与合并 3、集合操作 4、数据排序 5、 记录是一行,字段是一列
1、转换与合并 left_join(a, b, by = “x1”)： 向数据集a中加入匹配的数据集b记录（行）。
right_join(a, b, by = “x1”)： 向数据集b中加入匹配的数据集a记录。
inner_join(a, b, by = “x1”)： 合并数据。仅保留匹配的记录。
full_join(a, b, by = “x1”)： 合并数据。保留所有记录，所有行。没有的用NA填充
library(dplyr) a=data.frame(x1=c(&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;),x2=c(1:3)) b=data.frame(x1=c(&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;D&amp;quot;),x3=c(&amp;quot;T&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;T&amp;quot;)) a;b ## x1 x2 ## 1 A 1 ## 2 B 2 ## 3 C 3 ## x1 x3 ## 1 A T ## 2 B F ## 3 D T left_join(a, b, by = &amp;quot;x1&amp;quot;)# 向数据集a中加入匹配的数据集b记录。 ## x1 x2 x3 ## 1 A 1 T ## 2 B 2 F ## 3 C 3 &amp;lt;NA&amp;gt; right_join(a, b, by = &amp;quot;x1&amp;quot;)# 向数据集b中加入匹配的数据集a记录。 ## x1 x2 x3 ## 1 A 1 T ## 2 B 2 F ## 3 D NA T inner_join(a, b, by = &amp;quot;x1&amp;quot;)# 合并数据。仅保留匹配的记录。 ## x1 x2 x3 ## 1 A 1 T ## 2 B 2 F full_join(a, b, by = &amp;quot;x1&amp;quot;)# 合并数据。保留所有记录，所有行，没有的用NA填充 ## x1 x2 x3 ## 1 A 1 T ## 2 B 2 F ## 3 C 3 &amp;lt;NA&amp;gt; ## 4 D NA T 2、筛选与合并 semi_join(a, b, by = “x1”)： 数据集a中能与数据集b匹配的记录。</description>
    </item>
    
    <item>
      <title>dplyr -- 2实战</title>
      <link>/post/2018-01-03-dplyrshizhan2/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018-01-03-dplyrshizhan2/</guid>
      <description>1.1、选择行filter() 1.2、选择列 select() 1.3、排序arrange() 1.4、添加新变量mutate 1.5 汇总(行): summarise() 1.6、分组动作 把前两天的两篇文章合并，解决方法：名字还是不能太长，在content目录下新建test目录，把它放在content目录下的test目录，不放在post目录，我的test目录只有两篇文章
1.1、选择行filter() 安装nycflights13包，该软件包中的飞机航班数据将用于本文中dplyr包各个函数的演示
library(dplyr) library(nycflights13) 函数tbl_df()将过长过大的数据集转换为显示更友好的 tbl_df 类型:
flights &amp;lt;- tbl_df(flights) head(flights) #有336,776 x 19 ## # A tibble: 6 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## # … with 11 more variables: arr_delay &amp;lt;dbl&amp;gt;, carrier &amp;lt;chr&amp;gt;, flight &amp;lt;int&amp;gt;, ## # tailnum &amp;lt;chr&amp;gt;, origin &amp;lt;chr&amp;gt;, dest &amp;lt;chr&amp;gt;, air_time &amp;lt;dbl&amp;gt;, distance &amp;lt;dbl&amp;gt;, ## # hour &amp;lt;dbl&amp;gt;, minute &amp;lt;dbl&amp;gt;, time_hour &amp;lt;dttm&amp;gt; filter(flights,origin == &amp;quot;JFK&amp;quot;,month == 6L) #－ 获取六月份所有从”JFK”机场起飞的航班 ## # A tibble: 9,472 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; ## 1 2013 6 1 2 2359 3 341 350 ## 2 2013 6 1 538 545 -7 925 922 ## 3 2013 6 1 539 540 -1 832 840 ## 4 2013 6 1 553 600 -7 700 711 ## 5 2013 6 1 554 600 -6 851 908 ## 6 2013 6 1 557 600 -3 934 942 ## 7 2013 6 1 559 600 -1 856 930 ## 8 2013 6 1 606 610 -4 847 906 ## 9 2013 6 1 609 615 -6 759 808 ## 10 2013 6 1 615 610 5 837 847 ## # … with 9,462 more rows, and 11 more variables: arr_delay &amp;lt;dbl&amp;gt;, ## # carrier &amp;lt;chr&amp;gt;, flight &amp;lt;int&amp;gt;, tailnum &amp;lt;chr&amp;gt;, origin &amp;lt;chr&amp;gt;, dest &amp;lt;chr&amp;gt;, ## # air_time &amp;lt;dbl&amp;gt;, distance &amp;lt;dbl&amp;gt;, hour &amp;lt;dbl&amp;gt;, minute &amp;lt;dbl&amp;gt;, time_hour &amp;lt;dttm&amp;gt; slice(flights,1:2) #选取前面的1:2行 ## # A tibble: 2 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## # … with 11 more variables: arr_delay &amp;lt;dbl&amp;gt;, carrier &amp;lt;chr&amp;gt;, flight &amp;lt;int&amp;gt;, ## # tailnum &amp;lt;chr&amp;gt;, origin &amp;lt;chr&amp;gt;, dest &amp;lt;chr&amp;gt;, air_time &amp;lt;dbl&amp;gt;, distance &amp;lt;dbl&amp;gt;, ## # hour &amp;lt;dbl&amp;gt;, minute &amp;lt;dbl&amp;gt;, time_hour &amp;lt;dttm&amp;gt; sample_n(flights, 4, replace = TRUE)# 随机选取4条数据记录。 ## # A tibble: 4 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; ## 1 2013 8 22 1857 1705 112 2150 2020 ## 2 2013 5 27 1958 1925 33 2152 2129 ## 3 2013 9 10 1345 1345 0 1520 1520 ## 4 2013 11 21 1058 1100 -2 1311 1304 ## # … with 11 more variables: arr_delay &amp;lt;dbl&amp;gt;, carrier &amp;lt;chr&amp;gt;, flight &amp;lt;int&amp;gt;, ## # tailnum &amp;lt;chr&amp;gt;, origin &amp;lt;chr&amp;gt;, dest &amp;lt;chr&amp;gt;, air_time &amp;lt;dbl&amp;gt;, distance &amp;lt;dbl&amp;gt;, ## # hour &amp;lt;dbl&amp;gt;, minute &amp;lt;dbl&amp;gt;, time_hour &amp;lt;dttm&amp;gt; flights %&amp;gt;% top_n(4,dep_time) ## # A tibble: 29 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; ## 1 2013 10 30 2400 2359 1 327 337 ## 2 2013 11 27 2400 2359 1 515 445 ## 3 2013 12 5 2400 2359 1 427 440 ## 4 2013 12 9 2400 2359 1 432 440 ## 5 2013 12 9 2400 2250 70 59 2356 ## 6 2013 12 13 2400 2359 1 432 440 ## 7 2013 12 19 2400 2359 1 434 440 ## 8 2013 12 29 2400 1700 420 302 2025 ## 9 2013 2 7 2400 2359 1 432 436 ## 10 2013 2 7 2400 2359 1 443 444 ## # … with 19 more rows, and 11 more variables: arr_delay &amp;lt;dbl&amp;gt;, carrier &amp;lt;chr&amp;gt;, ## # flight &amp;lt;int&amp;gt;, tailnum &amp;lt;chr&amp;gt;, origin &amp;lt;chr&amp;gt;, dest &amp;lt;chr&amp;gt;, air_time &amp;lt;dbl&amp;gt;, ## # distance &amp;lt;dbl&amp;gt;, hour &amp;lt;dbl&amp;gt;, minute &amp;lt;dbl&amp;gt;, time_hour &amp;lt;dttm&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>dplyr -- 1基本函数简介</title>
      <link>/md/2018-01-01-dplyr/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/md/2018-01-01-dplyr/</guid>
      <description>0、dplyr初始 由于R语言每一个步骤没有赋值的话，是不会改变原有的数据，都是建立一个新的数据。原有数据不改变。
dplyr::tbl_df(iris)： 将数据转化为tbl类。只会显示适合屏幕大小的数据：
dplyr::glimpse(iris)： tbl数据的信息密集概括。 类似str()函数
dplyr::%&amp;gt;%： 将左边的对象作为第一个参数（或参数 .）传递到右边的函数中。利用%&amp;gt;%进行“Piping”管道操作增强了代码的可读性，
x %&amp;gt;% f(y) 相当于 f(x, y) y %&amp;gt;% f(x, ., z) 相当于 f(x, y, z ) 1、filter 行过滤 **filter(iris, Sepal.Length &amp;gt; 7) ：**抽取符合逻辑条件的数据记录。 **distinct(iris) ：**删除重复记录。 distinct(iris, Species) 保留iris某一列的唯一值 **sample_frac(iris, 0.5, replace = TRUE) ：**随机选取部分数据(占总体的0.5)记录。 **sample_n(iris, 10, replace = TRUE) ：**随机选取n条数据记录。 **slice(iris, 10:15) ：**通过位置选取数据记录。 **top_n(storms, 2, date) ：**选取并排列前n条数据记录 （若为分组数据则按组排序） 2、select 列过滤 rename(.data, ...) rename_all(.tbl, .funs = list(), ...) rename_if(.tbl, .predicate, .funs = list(), .</description>
    </item>
    
    <item>
      <title>tibble包的列和行名相互转换以及添加行和列</title>
      <link>/md/2017-12-31-tibble%E5%8C%85%E7%9A%84%E5%88%97-%E8%A1%8C%E5%90%8D%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/md/2017-12-31-tibble%E5%8C%85%E7%9A%84%E5%88%97-%E8%A1%8C%E5%90%8D%E8%BD%AC%E6%8D%A2/</guid>
      <description>1、列与行名相互转化 tibble包：
has_rownames(df)：检查是否存在行名
remove_rownames(df) ： 移除行名
rownames_to_column(df, var = &amp;ldquo;rowname&amp;rdquo;) ： 行名变为某列
rowid_to_column(df, var = &amp;ldquo;rowid&amp;rdquo;)： 行名变为某列,只能变为数字,个人不推荐 column_to_rownames(df, var = &amp;ldquo;rowname&amp;rdquo;) ： 某列变为行名，并删除某列,要求这个列值唯一
library(tibble) head(mtcars) has_rownames(mtcars) #检查是否存在行名 new_mtcars=rownames_to_column(mtcars, var = &amp;#34;new_col&amp;#34;) #行名变为某列,行名此时被移除 head(new_mtcars) has_rownames(rownames_to_column(mtcars, var = &amp;#34;new_col&amp;#34;)) has_rownames(rowid_to_column(mtcars, var = &amp;#34;new_col&amp;#34;)) df=remove_rownames(mtcars)#： 移除行名 head(df) column_to_rownames(new_mtcars, var = &amp;#34;new_col&amp;#34;)# 某列变为行名，并删除某列,要求这个列值唯一 2、添加行与列 添加行：
add_row(.data, &amp;hellip;, .before = NULL, .after = NULL) 添加列：
add_column(.data, &amp;hellip;, .before = NULL, .after = NULL) .before 指添加在第n行(列)，默认在最后 .</description>
    </item>
    
    <item>
      <title>R语言标准化数据处理</title>
      <link>/post/2017-11-13-%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-11-13-%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96%E6%96%B9%E6%B3%95/</guid>
      <description>##　1、标准化——数据处理 ***
preProcess(x, method = c(&amp;quot;center&amp;quot;, &amp;quot;scale&amp;quot;), thresh = 0.95, pcaComp = NULL, na.remove = TRUE, k = 5, knnSummary = mean, outcome = NULL, fudge = 0.2, numUnique = 3, verbose = FALSE, freqCut = 95/5,　uniqueCut = 10, cutoff = 0.9, ...) predict(object, newdata, ...) x: 为一个矩阵或数据框，对于非数值型变量将被忽略　method: 指定数据标准化的方法，默认为“center”和“scale”。（必须同时使用这两个，若选一个只能对应中心化或均值化）
其中center表示预测变量值减去均值；scale表示预测变量值除以标准差，故默认标准化方法就是\((x-mu)/std\)。
如果使用range方法，则数据标准为[0,1]的范围，即\((x-min)/(max-min)\)。 ppMethods &amp;lt;- c(&amp;quot;BoxCox&amp;quot;, &amp;quot;YeoJohnson&amp;quot;, &amp;quot;expoTrans&amp;quot;, &amp;quot;invHyperbolicSine&amp;quot;, &amp;quot;center&amp;quot;, &amp;quot;scale&amp;quot;, &amp;quot;range&amp;quot;, &amp;quot;knnImpute&amp;quot;, &amp;quot;bagImpute&amp;quot;, &amp;quot;medianImpute&amp;quot;, &amp;quot;pca&amp;quot;, &amp;quot;ica&amp;quot;, &amp;quot;spatialSign&amp;quot;, &amp;quot;ignore&amp;quot;, &amp;quot;keep&amp;quot;, &amp;quot;remove&amp;quot;, &amp;quot;zv&amp;quot;, &amp;quot;nzv&amp;quot;, &amp;quot;conditionalX&amp;quot;, &amp;quot;corr&amp;quot;) thresh:如果使用主成分分析（PCA)方法，该参数指定累计方差至少达到0.</description>
    </item>
    
    <item>
      <title>数据集划分—-训练集和测试集方法</title>
      <link>/md/2017-11-13-%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/md/2017-11-13-%E6%95%B0%E6%8D%AE%E9%9B%86%E5%88%92%E5%88%86/</guid>
      <description>1.随机采样sample()&amp;mdash;例：iris数据 sample(x, size, replace = FALSE, prob = NULL) Index = sample(nrow(iris),size = nrow(iris)*0.8) trian_data = iris[Index,] #作为训练集 test_data = iris[-Index,] #作为测试集 类似的还有dplyr包中的sample_n函数
sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL)
2. carte包&amp;ndash;createDatePartition 来进行分区抽样 inTrain =createDataPartition(响应变量y ,p=0.8,list=FALSE)
inTrain : 产生对应数据集行的索引 y 要分类或预测的变量, p 对应y的数据个数的概率 library(caret) set.seed(2012) #随机种子 Index =createDataPartition(iris$Species,p=0.8,list=FALSE) # 不知道为何？ iris[,5]不能使用 trian_data = iris[Index,] #作为训练集 test_data = iris[-Index,] #作为测试集 # 同样用上面第一种方法 产生数据集即可 3. dplyr::sample_frac()函数 sample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .</description>
    </item>
    
    <item>
      <title>R语言文件目录相关操作</title>
      <link>/md/2017-04-08-r%E4%B8%AD%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 08 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/md/2017-04-08-r%E4%B8%AD%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</guid>
      <description>1. 文件系统介绍 R语言对文件系统的操作，包括文件操作和目录操作，函数API都定义在base包中。
2. 目录操作 2.1 查看目录
查看当前目录下的子目录。
setwd() #设定某个目录为当前目录 getwd() # 当前的目录 list.dirs() # 查看当前目录的子目录 参数详见dir() dir() #查看当前目录的子目录和文件。 dir(path=&amp;#34;C:/windows&amp;#34;)#查看指定目录的子目录和文件 dir(path=&amp;#34;C:/windows&amp;#34;,all.files=TRUE)# 列出目录下所有的目录和文件，包括隐藏文件 dir(path=&amp;#34;C:/windows&amp;#34;,pattern=&amp;#39;^R&amp;#39;)#只列出以字母R开头的子目录或文件 file.info(&amp;#34;.&amp;#34;) # 查看当前目录权限 2.2 创建目录
dir.create(&amp;#34;your dir&amp;#34;) # 在当前目录下，新建一个目录 dir.create(path=&amp;#34;a1/b2/c3&amp;#34;,recursive = TRUE) #递归创建一个3级子目录./a1/b2/c3，直接创建会出错 2.3 检查目录是否存在
system(&amp;#34;tree&amp;#34;) # 通过系统命令查看目录结构 file.exists(&amp;#34;./a1&amp;#34;) # 查看某个目录是否存在,可以多层次调用目录 2.4 检查目录的权限
df&amp;lt;-dir(full.names = TRUE) #获取当前目录的所有目录(不含子目录)和文件名（含后缀） file.access(df, model=0) == 0 # 检查文件或目录是否存在，mode=0 # 检查文件或目录是否可执行，mode=1，目录为可以执行 # 检查文件或目录是否可写，mode=2 # 检查文件或目录是否可读，mode=4 2.5修改目录权限。
Sys.chmod(&amp;#34;./create&amp;#34;, mode = &amp;#34;0555&amp;#34;, use_umask = TRUE) # 修改目录权限，所有用户只读 2.</description>
    </item>
    
    <item>
      <title>knn算法简介</title>
      <link>/post/2017-03-23-knn%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 23 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-03-23-knn%E7%AE%97%E6%B3%95/</guid>
      <description>行业应用：比如文字识别、面部识别、预测某人是否喜欢推荐电影
基因模式识别：比如用于检测某种疾病，更适合于稀有事件的分类问题（客户流失识别）
应用场合：通常最近邻分类器适用特征与目标类之间的关系比较复杂的数字类型或者二者关系难以理解，但是相似类间的特征都是相似的 特点：
1. 简单有效，对数据分布没有假设，数据训练也很快。
但是他没有模型输出，因此限制了对特征的理解。
分类阶段比较慢。
需要标准化(nominal)特征以及缺少数据需要预先处理
优点 缺点 简单且有效 不产生模型．在发现特彻之间关系上的能力有限 对数据的分布没有要求 分类阶段很慢, 需要大量的内存 训练阶段很快 名义变量（特征变量）和缺失数据需要额外处理 k的取值：
1. k通常在3~10之间直接取值（看分析者的心情）
2. 可采用一般方法：k等于训练数据个数的平方根（15个数据，k可能取4）
1. 导入数据 #导入数据 # import the CSV file wbcd &amp;lt;- read.csv(&amp;quot;wisc_bc_data.csv&amp;quot;, stringsAsFactors = FALSE) # 查看一下数据结构，发现除了要预测的变量diagnosis是字符型变量其余全是数字型变量 str(wbcd) ## &amp;#39;data.frame&amp;#39;: 569 obs. of 32 variables: ## $ id : int 87139402 8910251 905520 868871 9012568 906539 925291 87880 862989 89827 ... ## $ diagnosis : chr &amp;quot;B&amp;quot; &amp;quot;B&amp;quot; &amp;quot;B&amp;quot; &amp;quot;B&amp;quot; .</description>
    </item>
    
    <item>
      <title>回归树与模型树</title>
      <link>/post/2017-02-18-tree-model/</link>
      <pubDate>Sat, 18 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-02-18-tree-model/</guid>
      <description>1、理解回归树与模型树 决策树可用于聚类（类别变量），也可用于数值预测,但是本节只考虑决策树用于数值预测.
决策树用于数值预测可以分为回归树和模型树
回归树: 回归树中并没用使用线性回归的方法，而是基于到达叶节点的案例的平均值做出预测
模型树: 模型树和回归树以大致相同的方式生长，但是在每个叶节点，根据到达该节点的案例建立多元线性回归模型。根据叶节点的数目，一棵模型树可能会建立几十甚至上百个这样的模型，可能会使模型树比同等的回归树更难解释，但好处也行能提高精确度。
2、回归树与模型树的优缺点 优点 缺点 将决策树的优点对数值型数据建立模型的能力相结合 不像线性回归那么常用 能自动选择特征，允许该方法与大量特征一起使用 需要大量的训练数据 不需要使用者事先指定模型 难以确定单个特征对于结果的总体净影响 拟合某些类型的数据可能会比线性回归好 可能比回归模型难以解释 不要求用统计的知识来解释模型 用于数值预测的决策树的建立方式与用于分类的决策树建立的方式大致相同。从根节点开始，按照特征使用分而治之的决策对数据进行划分，在进行一次分割后，将会导致结果最大化的均匀增长。
在分类决策树中，一致性(均匀性)是有熵值度量 ，而对于数值型数据是未定义的， 对于数值型决策，一致性(均匀性)可通过统计量(方差、标准差、平均绝对偏差)来度量,根据使用的决策树生长算法，度量方法可能用所不同，但基本原理相同. 常见的一个分割标准成为标准偏差减少(Standard Deciation Reduction,SDR),其公式定义如下\[SDR=sd(T)\]
3、例子——-估计葡萄酒的质量 白葡萄酒包含4898个葡萄酒案例的11种化学特征的信息，对于每种葡萄酒，实验室分析测量的特征包括酸性、含糖量、氯化物含量、硫的含量、酒精度、PH值和密度值
3.1读入数据 其所有特征都是数值型
wine &amp;lt;- read.csv(&amp;quot;whitewines.csv&amp;quot;) 研究一下结果变量的分布,由于是离散的，可用直方图来研究葡萄酒质量的分布：
hist(wine$quality) 符合正态分布。大约以数值为6为中心(也可用summary()函数发现一些数据的异常值等等)，最后划分训练数据与测试数据(数据是随机排序),75%的训练数据，25%的测试数据
wine_train &amp;lt;- wine[1:3750, ] wine_test &amp;lt;- wine[3751:4898, ] 3.2基于数据训练模型—-回归树 library(rpart) m.rpart &amp;lt;- rpart(quality ~ ., data = wine_train) m.rpart# 获取该树的基本信息,#summary(m.rpart) ## n= 3750 ## ## node), split, n, deviance, yval ## * denotes terminal node ## ## 1) root 3750 2945.</description>
    </item>
    
    <item>
      <title>ggfortify包简介</title>
      <link>/post/2017-02-01-ggfortify1jianjie/</link>
      <pubDate>Sun, 12 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-02-01-ggfortify1jianjie/</guid>
      <description>ggfortify 是一个简单易用的R软件包，它可以仅仅使用一行代码来对许多受欢迎的R软件包结果进行二维可视化，这让统计学家以及数据科学家省去了许多繁琐和重复的过程，不用对结果进行任何处理就能以 ggplot 的风格画出好看的图，大大地提高了工作的效率。
接下来我将简单介绍一下怎么用 ggplot2 和 ggfortify 来很快地对PCA、聚类以及LFDA的结果进行可视化，然后将简单介绍用 ggfortify 来对时间序列进行快速可视化的方法。一下都是个人理解，
1、PCA (主成分分析) 其实本包，大多数画图都是采用主成分（不包括因子分析）降维得到两个主成分，在进一步使其主成分为坐标，对应与每个点给出相应的颜色和类别
ggfortify 使 ggplot2 知道怎么诠释PCA对象。加载好 ggfortify 包之后, 你可以对stats::prcomp 和stats::princomp对象使用 ggplot2::autoplot。
autoplot()函数是ggplot2中的，不过ggfortify包里面有泛函s3类的autoplot解释这个函数
ggbiplot()函数中的参数就是autoplot()函数中的参数
autoplot(object, data = NULL, scale = 1, x = 1, y = 2, ...) object : 对象 data : 对应的数据框 colour = &amp;#39;Species&amp;#39; : 若有分类因子变量，可以对不同的类别添加颜色,当为连续值时为逐渐变色 shape = FALSE ： 调整点的形状，可以让所有的点消失，只留下标识（可以为具体的数字，就是形状类型） main 、xlab 、ylab ： 标题 label = TRUE label.size = 3 : 可以给每个点加上标识（以rownames为标准），也可以调整标识的大小.（默认为FALSE） label.label : 标识标签（默认rownames） label.</description>
    </item>
    
    <item>
      <title>2、caret包其他函数介绍</title>
      <link>/post/2017-01-28-caret1otherfun/</link>
      <pubDate>Sat, 28 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/2017-01-28-caret1otherfun/</guid>
      <description>一、创建哑变量 如果你有一个因子型变量需要进行哑变量处理，你会怎么办？也许你会根据该变量的m个水平数构建m-1个哑变量，不错，这样的思路是没有问题的。但如果发现该变量确实很重要，而且水平数目非常多，那你一定会抓狂！如果你会caret包中的dummyVars()函数，那将如虎添翼，效率倍增~我们来看看该函数是如何实现哑变量构建的。
函数语法及参数介绍：
dummyVars(formula, data, sep = &#34;.&#34;,levelsOnly = FALSE, fullRank = FALSE, ...) predict(object, newdata, na.action = na.pass, ...)
formula: 公式右边请指定需要处理为哑变量的因子型变量
sep:设置变量与水平间的分割符，默认为实心点。如x.a，x就是变量名,a就是x的一个水平
levelsOnly:逻辑值，如果为True，则列名中剔除原变量名。如x.a变为a,把因子作为变量名
object:为dummyVars()函数构成的结果
newdata:需要处理的新数据
na.action:缺失值的对待，变量水平中如果有缺失值，则结果仍为缺失值
library(caret) dummy &amp;lt;- dummyVars(formula = ~ ., data = iris,levelsOnly=TRUE)#把因子作为变量名 pred &amp;lt;- predict(dummy, newdata = iris) head(pred) ## Sepal.Length Sepal.Width Petal.Length Petal.Width setosa versicolor virginica ## 1 5.1 3.5 1.4 0.2 1 0 0 ## 2 4.9 3.0 1.4 0.2 1 0 0 ## 3 4.</description>
    </item>
    
    <item>
      <title>R语言与可视化</title>
      <link>/md/2017-01-30-r%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/md/2017-01-30-r%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</guid>
      <description>R可视化 静态图形 动态图形 静态图形 基础统计图 grDevice Lattile Grid ggplot2 地图 ggmap ggplot2 maptools maps sp 网络 igraph linkcomm statmet 特殊图形 基因组的(ggbio……) 动态图形 非浏览器平台 rgl rggobi(ggobi) animation(animation) RGtk2 iplots 动态图形 浏览器平台 ggvis rCharts(http://ramnathv.github.io/rCharts/) recharts (https://recharts.cosx.org/) plotly(https://plotly-r.com/, https://plot.ly/r/) googlevis Remap(https://github.com/Lchiffon/REmap) htmlwidgets 框架 leaflet(地图) dygraphs (时间序列) diagrammeR(diagram) – 化学结构 network3D (网格) DT (表格) threeJS (3D数据展示) </description>
    </item>
    
    <item>
      <title>Rweka包解读</title>
      <link>/md/2015-11-16-rweka/</link>
      <pubDate>Mon, 16 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/md/2015-11-16-rweka/</guid>
      <description>1. 数据输入和输出 WOW()：查看Weka函数的参数。 Weka_control()：设置Weka函数的参数。 read.arff()：读(ARFF)格式的数据。一般的数据需要用这两个函数（先写再读）进行转换成（arff）格式的数据 write.arff()：将数据写入Weka Attribute-Relation File Format (ARFF)格式的文件。 2. 数据预处理 Normalize()：无监督的标准化连续性数据,即min-max标准化。对于字符、逻辑、因子变量跳过，只对连续数据标准化
Discretize()：用MDL(最小描述长度)方法，有监督的离散化连续性数值数据。感觉用处不大，把连续的数据全离散成“all”字符
3. 分类和回归 IBk()：k最近邻分类，用法和LBR一样
LBR()：naive Bayes法分类
RWeka包中的IBK函数实现knn算法 * model=IBk(formula, data, subset, na.action,control = Weka_control(), options = NULL) + formula:公式，分类变量~特征，和回归一样 + data : 训练数据集,必须为*.raff格式的数据,对于R中的数据， + 可以先把某个对象先用write.arff(iris,&amp;#39;iris.arff&amp;#39;)写成raff文件格式 + 再次用read.arff(&amp;#34;iris.arff&amp;#34;)读入R内存中即可 + control:参数控制 control=Weka_control(K= 22,X = TRUE) + X K都为大写，表示自动选取1：K=22里面最适合的K近邻分类 * evaluate_Weka_classifier(object, newdata = NULL, cost = NULL, numFolds = 0, complexity = FALSE, class = FALSE, seed = NULL, ...) + object: 一个Weka_classifier对象,Rweka建立的分类对象模型 + newdata: 测试数据，若为省略或为0 ，则为训练数据 + numFolds： k-交叉验证 J48()：C4.</description>
    </item>
    
    <item>
      <title>GA包---遗传算法</title>
      <link>/post/2015-11-09-ga/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/2015-11-09-ga/</guid>
      <description>GA包—遗传算法 2022年3月23更新
参考: Genetic Algorithms • GA (luca-scr.github.io)
1、用法：(默认求解最大值) 注意: 默认求解最大值 ga(type = c(&amp;quot;binary&amp;quot;, &amp;quot;real-valued&amp;quot;, &amp;quot;permutation&amp;quot;), fitness, ..., # fitness:适应度函数 lower, upper, #解得下界/解得上界(多元变量为一个向量) nBits, #一个种群用二进制编码的长度是多少(长度越大代表精度越高,一般等于变量的个数即可) population = gaControl(type)$population, # 初始种群 selection = gaControl(type)$selection, #选择 crossover = gaControl(type)$crossover, #交叉 mutation = gaControl(type)$mutation, #变异 popSize = 50, #种群大小 pcrossover = 0.8, #交叉概率（默认0.8） pmutation = 0.1, #变异概率（默认0.1） elitism = base::max(1, round(popSize*0.05)), #代沟(默认情况下,前5%个体将在每个迭代中保留) updatePop = FALSE, postFitness = NULL, maxiter = 100, # 最大迭代次数(默认100) run = maxiter, #表示连续出现一定数目的目标函数值未改变,则GA终止搜索 maxFitness = Inf, # 适应度函数的上界,GA搜索后中断 names = NULL, # 表示决策变量名的向量 suggestions = NULL, # 包含某些指定的初始种群 optim = FALSE, # optim默认值为FALSE，用于确定是否应使用使用通用优化算法的局部搜索。有关更多详细信息和更精细的控制，请参阅参数optimArgs。 # 简单理解, 即optim= T时, 表面进过一定次数的迭代后从 GA 最优解开始最为 optim函数的初始值,开始进行局部优化 # optimArgs 控制本地搜索算法的列表，具有以下组件： optimArgs = list(method = &amp;quot;L-BFGS-B&amp;quot;, # 可以是optim函数中的方法 poptim = 0.</description>
    </item>
    
  </channel>
</rss>
